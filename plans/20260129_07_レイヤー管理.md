# 工程07: レイヤー管理機能

## 目的・概要

インポート・変換された3Dデータ（点群・メッシュ）をレイヤーとして管理し、表示ON/OFF、不透明度調整、順序変更、ロック機能などを提供する。ベースマップと3Dデータレイヤーの重ね合わせ、地形スナップ設定も実装する。

## 対応する機能要件

- FR-13: レイヤー管理（表示ON/OFF、不透明度、順序、ロック）
- FR-14: 地形（Terrain）と重ね合わせ、地表スナップ

## 実装タスク詳細

### 1. レイヤーデータモデル

```dart
// lib/data/models/layer.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'layer.freezed.dart';
part 'layer.g.dart';

/// レイヤータイプ
enum LayerType {
  /// ベースマップ（衛星写真、地図タイル等）
  basemap('ベースマップ', 'basemap'),
  
  /// 点群データ
  pointCloud('点群', 'pointcloud'),
  
  /// メッシュデータ
  mesh('メッシュ', 'mesh'),
  
  /// 地形データ
  terrain('地形', 'terrain'),
  
  /// 配置物グループ
  placements('配置物', 'placements'),
  
  /// 計測結果
  measurements('計測', 'measurements'),
  
  /// 注釈・マーカー
  annotations('注釈', 'annotations');

  final String displayName;
  final String id;
  const LayerType(this.displayName, this.id);
}

/// レイヤー設定
@freezed
class Layer with _$Layer {
  const factory Layer({
    /// 一意識別子
    required String id,
    
    /// レイヤー名
    required String name,
    
    /// レイヤータイプ
    required LayerType type,
    
    /// 表示フラグ
    @Default(true) bool visible,
    
    /// 不透明度 (0.0-1.0)
    @Default(1.0) double opacity,
    
    /// 表示順序（大きいほど上）
    @Default(0) int order,
    
    /// ロック状態（編集不可）
    @Default(false) bool locked,
    
    /// 展開状態（子レイヤーの表示）
    @Default(true) bool expanded,
    
    /// データソースパス（3D Tiles等）
    String? sourcePath,
    
    /// 変換元ファイルパス
    String? originalPath,
    
    /// スタイル設定
    LayerStyle? style,
    
    /// メタ情報
    Map<String, dynamic>? metadata,
    
    /// 子レイヤー
    @Default([]) List<Layer> children,
  }) = _Layer;

  factory Layer.fromJson(Map<String, dynamic> json) => _$LayerFromJson(json);
  
  /// 点群レイヤーを作成
  factory Layer.pointCloud({
    required String id,
    required String name,
    required String sourcePath,
    String? originalPath,
  }) {
    return Layer(
      id: id,
      name: name,
      type: LayerType.pointCloud,
      sourcePath: sourcePath,
      originalPath: originalPath,
      style: const LayerStyle(
        pointSize: 2.0,
        colorMode: PointColorMode.rgb,
      ),
    );
  }
  
  /// メッシュレイヤーを作成
  factory Layer.mesh({
    required String id,
    required String name,
    required String sourcePath,
    String? originalPath,
  }) {
    return Layer(
      id: id,
      name: name,
      type: LayerType.mesh,
      sourcePath: sourcePath,
      originalPath: originalPath,
    );
  }
}

/// レイヤースタイル
@freezed
class LayerStyle with _$LayerStyle {
  const factory LayerStyle({
    /// 点群の点サイズ
    @Default(2.0) double pointSize,
    
    /// 点群の色モード
    @Default(PointColorMode.rgb) PointColorMode colorMode,
    
    /// 単色指定時の色
    String? solidColor,
    
    /// 高さグラデーション設定
    HeightGradient? heightGradient,
    
    /// ワイヤーフレーム表示
    @Default(false) bool wireframe,
    
    /// 両面レンダリング
    @Default(true) bool doubleSided,
    
    /// シルエット表示
    @Default(false) bool silhouette,
  }) = _LayerStyle;

  factory LayerStyle.fromJson(Map<String, dynamic> json) => 
      _$LayerStyleFromJson(json);
}

/// 点群の色モード
enum PointColorMode {
  rgb('RGB'),
  intensity('強度'),
  classification('分類'),
  height('高さ'),
  solid('単色');
  
  final String displayName;
  const PointColorMode(this.displayName);
}

/// 高さグラデーション
@freezed
class HeightGradient with _$HeightGradient {
  const factory HeightGradient({
    required double minHeight,
    required double maxHeight,
    @Default(['#0000FF', '#00FF00', '#FFFF00', '#FF0000']) List<String> colors,
  }) = _HeightGradient;

  factory HeightGradient.fromJson(Map<String, dynamic> json) => 
      _$HeightGradientFromJson(json);
}
```

### 2. cesium_bridge.js レイヤー拡張

```javascript
// assets/cesium/cesium_bridge.js に追加

/**
 * 3Dデータレイヤー管理
 */
const dataLayers = new Map();

/**
 * 3D Tilesレイヤーを追加
 * @param {Object} config - レイヤー設定
 */
function addTilesetLayer(config) {
  const tileset = new Cesium.Cesium3DTileset({
    url: config.sourcePath,
    maximumScreenSpaceError: config.maxError || 16,
    maximumMemoryUsage: config.maxMemory || 512,
  });

  tileset.readyPromise.then(() => {
    // スタイル設定
    if (config.style) {
      applyTilesetStyle(tileset, config.style);
    }
    
    // 初期表示設定
    tileset.show = config.visible !== false;
    
    // 地形クランプ設定
    if (config.clampToGround) {
      tileset.clampToGround = true;
    }
    
    sendToFlutter('layerAdded', {
      id: config.id,
      boundingSphere: {
        center: Cesium.Cartographic.fromCartesian(tileset.boundingSphere.center),
        radius: tileset.boundingSphere.radius
      }
    });
  }).catch((error) => {
    sendToFlutter('layerError', {
      id: config.id,
      error: error.message
    });
  });

  viewer.scene.primitives.add(tileset);
  dataLayers.set(config.id, {
    tileset: tileset,
    type: config.type,
    config: config
  });
}

/**
 * レイヤーを削除
 * @param {string} layerId - レイヤーID
 */
function removeLayer(layerId) {
  const layer = dataLayers.get(layerId);
  if (layer) {
    viewer.scene.primitives.remove(layer.tileset);
    dataLayers.delete(layerId);
  }
}

/**
 * レイヤーの表示/非表示を切り替え
 * @param {string} layerId - レイヤーID
 * @param {boolean} visible - 表示フラグ
 */
function setLayerVisible(layerId, visible) {
  const layer = dataLayers.get(layerId);
  if (layer) {
    layer.tileset.show = visible;
  }
}

/**
 * レイヤーの不透明度を設定
 * @param {string} layerId - レイヤーID
 * @param {number} opacity - 不透明度 (0-1)
 */
function setLayerOpacity(layerId, opacity) {
  const layer = dataLayers.get(layerId);
  if (layer) {
    // 3D Tilesのスタイルで透明度を設定
    layer.tileset.style = new Cesium.Cesium3DTileStyle({
      color: `color('white', ${opacity})`
    });
  }
}

/**
 * 点群スタイルを適用
 * @param {Cesium.Cesium3DTileset} tileset - タイルセット
 * @param {Object} style - スタイル設定
 */
function applyTilesetStyle(tileset, style) {
  const styleOptions = {};
  
  // 点サイズ
  if (style.pointSize) {
    styleOptions.pointSize = style.pointSize;
  }
  
  // 色モード
  switch (style.colorMode) {
    case 'rgb':
      styleOptions.color = 'color("white")';
      break;
    case 'intensity':
      styleOptions.color = 'color("gray") * ${INTENSITY}';
      break;
    case 'classification':
      styleOptions.color = {
        conditions: [
          ['${CLASSIFICATION} === 2', 'color("saddlebrown")'], // Ground
          ['${CLASSIFICATION} === 3', 'color("green")'],       // Low Vegetation
          ['${CLASSIFICATION} === 4', 'color("green")'],       // Medium Vegetation
          ['${CLASSIFICATION} === 5', 'color("darkgreen")'],   // High Vegetation
          ['${CLASSIFICATION} === 6', 'color("red")'],         // Building
          ['true', 'color("white")']
        ]
      };
      break;
    case 'height':
      if (style.heightGradient) {
        const { minHeight, maxHeight, colors } = style.heightGradient;
        styleOptions.color = {
          conditions: [
            [`\${POSITION}[2] < ${minHeight}`, `color("${colors[0]}")`],
            [`\${POSITION}[2] > ${maxHeight}`, `color("${colors[colors.length - 1]}")`],
            ['true', `color("${colors[1]}")`]
          ]
        };
      }
      break;
    case 'solid':
      styleOptions.color = `color("${style.solidColor || '#FFFFFF'}")`;
      break;
  }
  
  tileset.style = new Cesium.Cesium3DTileStyle(styleOptions);
}

/**
 * レイヤースタイルを更新
 * @param {string} layerId - レイヤーID
 * @param {Object} style - スタイル設定
 */
function updateLayerStyle(layerId, style) {
  const layer = dataLayers.get(layerId);
  if (layer) {
    applyTilesetStyle(layer.tileset, style);
  }
}

/**
 * レイヤーにズーム
 * @param {string} layerId - レイヤーID
 */
function zoomToLayer(layerId) {
  const layer = dataLayers.get(layerId);
  if (layer && layer.tileset.boundingSphere) {
    viewer.camera.flyToBoundingSphere(layer.tileset.boundingSphere, {
      duration: 1.5,
      offset: new Cesium.HeadingPitchRange(0, -0.5, 0)
    });
  }
}

/**
 * 地形の表示/非表示を切り替え
 * @param {boolean} visible - 表示フラグ
 */
function setTerrainVisible(visible) {
  if (visible) {
    viewer.terrainProvider = Cesium.createWorldTerrain();
  } else {
    viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
  }
}

/**
 * 全レイヤーの情報を取得
 */
function getAllLayers() {
  const layers = [];
  for (const [id, layer] of dataLayers) {
    layers.push({
      id: id,
      type: layer.type,
      visible: layer.tileset.show,
      ready: layer.tileset.ready
    });
  }
  sendToFlutter('layersInfo', { layers: layers });
}

// handleFlutterMessage に追加
function handleFlutterMessage(method, params) {
  switch (method) {
    // ... 既存のcase
    
    case 'addTilesetLayer':
      addTilesetLayer(params);
      break;
    case 'removeLayer':
      removeLayer(params.layerId);
      break;
    case 'setLayerVisible':
      setLayerVisible(params.layerId, params.visible);
      break;
    case 'setLayerOpacity':
      setLayerOpacity(params.layerId, params.opacity);
      break;
    case 'updateLayerStyle':
      updateLayerStyle(params.layerId, params.style);
      break;
    case 'zoomToLayer':
      zoomToLayer(params.layerId);
      break;
    case 'setTerrainVisible':
      setTerrainVisible(params.visible);
      break;
    case 'getAllLayers':
      getAllLayers();
      break;
  }
}
```

### 3. Flutter側 LayerController

```dart
// lib/infrastructure/webview/layer_controller.dart

/// レイヤー管理コントローラ
/// 
/// CesiumJS上の3Dデータレイヤーを管理する
class LayerController {
  final CesiumController _cesiumController;
  
  final List<Layer> _layers = [];
  final _layerStreamController = StreamController<List<Layer>>.broadcast();
  
  List<Layer> get layers => List.unmodifiable(_layers);
  Stream<List<Layer>> get layerStream => _layerStreamController.stream;

  LayerController(this._cesiumController) {
    _cesiumController.onLayerAdded = _onLayerAdded;
    _cesiumController.onLayerError = _onLayerError;
  }

  /// 3D Tilesレイヤーを追加
  Future<void> addTilesetLayer(Layer layer) async {
    await _cesiumController.executeMethod('addTilesetLayer', {
      'id': layer.id,
      'type': layer.type.id,
      'sourcePath': layer.sourcePath,
      'visible': layer.visible,
      'style': layer.style?.toJson(),
    });
    
    _layers.add(layer);
    _sortLayers();
    _notifyLayersChanged();
  }

  /// レイヤーを削除
  Future<void> removeLayer(String layerId) async {
    await _cesiumController.executeMethod('removeLayer', {
      'layerId': layerId,
    });
    
    _layers.removeWhere((l) => l.id == layerId);
    _notifyLayersChanged();
  }

  /// レイヤーの表示/非表示を切り替え
  Future<void> setLayerVisible(String layerId, bool visible) async {
    await _cesiumController.executeMethod('setLayerVisible', {
      'layerId': layerId,
      'visible': visible,
    });
    
    _updateLayer(layerId, (l) => l.copyWith(visible: visible));
  }

  /// レイヤーの不透明度を設定
  Future<void> setLayerOpacity(String layerId, double opacity) async {
    await _cesiumController.executeMethod('setLayerOpacity', {
      'layerId': layerId,
      'opacity': opacity.clamp(0.0, 1.0),
    });
    
    _updateLayer(layerId, (l) => l.copyWith(opacity: opacity));
  }

  /// レイヤーをロック/アンロック
  void setLayerLocked(String layerId, bool locked) {
    _updateLayer(layerId, (l) => l.copyWith(locked: locked));
  }

  /// レイヤーの順序を変更
  Future<void> reorderLayer(String layerId, int newOrder) async {
    _updateLayer(layerId, (l) => l.copyWith(order: newOrder));
    _sortLayers();
    _notifyLayersChanged();
    
    // TODO: CesiumJS側でも順序を反映（現状は再読み込み順）
  }

  /// レイヤースタイルを更新
  Future<void> updateLayerStyle(String layerId, LayerStyle style) async {
    await _cesiumController.executeMethod('updateLayerStyle', {
      'layerId': layerId,
      'style': style.toJson(),
    });
    
    _updateLayer(layerId, (l) => l.copyWith(style: style));
  }

  /// レイヤーにズーム
  Future<void> zoomToLayer(String layerId) async {
    await _cesiumController.executeMethod('zoomToLayer', {
      'layerId': layerId,
    });
  }

  /// 地形の表示/非表示を切り替え
  Future<void> setTerrainVisible(bool visible) async {
    await _cesiumController.executeMethod('setTerrainVisible', {
      'visible': visible,
    });
  }

  /// レイヤー情報を取得
  Layer? getLayer(String layerId) {
    return _layers.firstWhereOrNull((l) => l.id == layerId);
  }

  /// タイプでフィルタしたレイヤー一覧
  List<Layer> getLayersByType(LayerType type) {
    return _layers.where((l) => l.type == type).toList();
  }

  void _onLayerAdded(Map<String, dynamic> data) {
    final layerId = data['id'] as String;
    debugPrint('Layer added: $layerId');
  }

  void _onLayerError(Map<String, dynamic> data) {
    final layerId = data['id'] as String;
    final error = data['error'] as String;
    debugPrint('Layer error: $layerId - $error');
  }

  void _updateLayer(String layerId, Layer Function(Layer) updater) {
    final index = _layers.indexWhere((l) => l.id == layerId);
    if (index != -1) {
      _layers[index] = updater(_layers[index]);
      _notifyLayersChanged();
    }
  }

  void _sortLayers() {
    _layers.sort((a, b) => b.order.compareTo(a.order));
  }

  void _notifyLayersChanged() {
    _layerStreamController.add(List.unmodifiable(_layers));
  }

  void dispose() {
    _layerStreamController.close();
  }
}
```

### 4. レイヤーパネルUI

```dart
// lib/presentation/widgets/layer_panel.dart

import 'package:flutter/material.dart';

/// レイヤーパネル
class LayerPanel extends ConsumerWidget {
  const LayerPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final layers = ref.watch(layersProvider);
    
    return Column(
      children: [
        // ヘッダ
        _buildHeader(context, ref),
        const Divider(height: 1),
        
        // レイヤーリスト
        Expanded(
          child: ReorderableListView.builder(
            itemCount: layers.length,
            onReorder: (oldIndex, newIndex) {
              ref.read(layerControllerProvider).reorderLayer(
                layers[oldIndex].id,
                newIndex,
              );
            },
            itemBuilder: (context, index) {
              return _LayerTile(
                key: ValueKey(layers[index].id),
                layer: layers[index],
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildHeader(BuildContext context, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.all(8),
      child: Row(
        children: [
          const Icon(Icons.layers, size: 20),
          const SizedBox(width: 8),
          const Text('レイヤー', style: TextStyle(fontWeight: FontWeight.bold)),
          const Spacer(),
          IconButton(
            icon: const Icon(Icons.add, size: 20),
            onPressed: () => _showAddLayerMenu(context, ref),
            tooltip: 'レイヤーを追加',
          ),
        ],
      ),
    );
  }

  void _showAddLayerMenu(BuildContext context, WidgetRef ref) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ListTile(
            leading: const Icon(Icons.cloud_upload),
            title: const Text('点群/メッシュをインポート'),
            onTap: () {
              Navigator.pop(context);
              // インポートダイアログを表示
            },
          ),
          ListTile(
            leading: const Icon(Icons.map),
            title: const Text('ベースマップを追加'),
            onTap: () {
              Navigator.pop(context);
              // ベースマップ選択ダイアログを表示
            },
          ),
        ],
      ),
    );
  }
}

/// レイヤータイル
class _LayerTile extends ConsumerStatefulWidget {
  final Layer layer;

  const _LayerTile({super.key, required this.layer});

  @override
  ConsumerState<_LayerTile> createState() => _LayerTileState();
}

class _LayerTileState extends ConsumerState<_LayerTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final layer = widget.layer;
    
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        color: _isHovered ? Colors.grey.withOpacity(0.1) : null,
        child: ExpansionTile(
          leading: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              // 表示/非表示トグル
              IconButton(
                icon: Icon(
                  layer.visible ? Icons.visibility : Icons.visibility_off,
                  size: 18,
                  color: layer.visible ? null : Colors.grey,
                ),
                onPressed: () {
                  ref.read(layerControllerProvider)
                      .setLayerVisible(layer.id, !layer.visible);
                },
              ),
              // レイヤータイプアイコン
              _buildTypeIcon(layer.type),
            ],
          ),
          title: Text(
            layer.name,
            style: TextStyle(
              color: layer.visible ? null : Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
          subtitle: Text(
            layer.type.displayName,
            style: const TextStyle(fontSize: 12),
          ),
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (layer.locked)
                const Icon(Icons.lock, size: 16, color: Colors.grey),
              if (_isHovered) ...[
                IconButton(
                  icon: const Icon(Icons.zoom_in, size: 18),
                  onPressed: () {
                    ref.read(layerControllerProvider).zoomToLayer(layer.id);
                  },
                  tooltip: 'ズーム',
                ),
                IconButton(
                  icon: const Icon(Icons.more_vert, size: 18),
                  onPressed: () => _showLayerMenu(context),
                  tooltip: 'メニュー',
                ),
              ],
            ],
          ),
          children: [
            _buildLayerControls(layer),
          ],
        ),
      ),
    );
  }

  Widget _buildTypeIcon(LayerType type) {
    IconData icon;
    Color color;
    
    switch (type) {
      case LayerType.basemap:
        icon = Icons.map;
        color = Colors.blue;
        break;
      case LayerType.pointCloud:
        icon = Icons.scatter_plot;
        color = Colors.orange;
        break;
      case LayerType.mesh:
        icon = Icons.view_in_ar;
        color = Colors.purple;
        break;
      case LayerType.terrain:
        icon = Icons.terrain;
        color = Colors.brown;
        break;
      case LayerType.placements:
        icon = Icons.place;
        color = Colors.green;
        break;
      case LayerType.measurements:
        icon = Icons.straighten;
        color = Colors.red;
        break;
      case LayerType.annotations:
        icon = Icons.note;
        color = Colors.teal;
        break;
    }
    
    return Icon(icon, size: 20, color: color);
  }

  Widget _buildLayerControls(Layer layer) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 不透明度スライダー
          Row(
            children: [
              const SizedBox(width: 80, child: Text('不透明度')),
              Expanded(
                child: Slider(
                  value: layer.opacity,
                  min: 0,
                  max: 1,
                  divisions: 10,
                  label: '${(layer.opacity * 100).round()}%',
                  onChanged: (value) {
                    ref.read(layerControllerProvider)
                        .setLayerOpacity(layer.id, value);
                  },
                ),
              ),
              SizedBox(
                width: 40,
                child: Text('${(layer.opacity * 100).round()}%'),
              ),
            ],
          ),
          
          // 点群スタイル設定（点群の場合のみ）
          if (layer.type == LayerType.pointCloud) ...[
            const SizedBox(height: 8),
            _buildPointCloudStyleControls(layer),
          ],
        ],
      ),
    );
  }

  Widget _buildPointCloudStyleControls(Layer layer) {
    final style = layer.style ?? const LayerStyle();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 点サイズ
        Row(
          children: [
            const SizedBox(width: 80, child: Text('点サイズ')),
            Expanded(
              child: Slider(
                value: style.pointSize,
                min: 1,
                max: 10,
                divisions: 9,
                label: style.pointSize.round().toString(),
                onChanged: (value) {
                  ref.read(layerControllerProvider).updateLayerStyle(
                    layer.id,
                    style.copyWith(pointSize: value),
                  );
                },
              ),
            ),
          ],
        ),
        
        // 色モード
        Row(
          children: [
            const SizedBox(width: 80, child: Text('色')),
            Expanded(
              child: DropdownButton<PointColorMode>(
                value: style.colorMode,
                isExpanded: true,
                items: PointColorMode.values.map((mode) {
                  return DropdownMenuItem(
                    value: mode,
                    child: Text(mode.displayName),
                  );
                }).toList(),
                onChanged: (mode) {
                  if (mode != null) {
                    ref.read(layerControllerProvider).updateLayerStyle(
                      layer.id,
                      style.copyWith(colorMode: mode),
                    );
                  }
                },
              ),
            ),
          ],
        ),
      ],
    );
  }

  void _showLayerMenu(BuildContext context) {
    final layer = widget.layer;
    
    showModalBottomSheet(
      context: context,
      builder: (context) => Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ListTile(
            leading: const Icon(Icons.edit),
            title: const Text('名前を変更'),
            onTap: () {
              Navigator.pop(context);
              _showRenameDialog(context);
            },
          ),
          ListTile(
            leading: Icon(layer.locked ? Icons.lock_open : Icons.lock),
            title: Text(layer.locked ? 'ロック解除' : 'ロック'),
            onTap: () {
              Navigator.pop(context);
              ref.read(layerControllerProvider)
                  .setLayerLocked(layer.id, !layer.locked);
            },
          ),
          ListTile(
            leading: const Icon(Icons.zoom_in),
            title: const Text('このレイヤーにズーム'),
            onTap: () {
              Navigator.pop(context);
              ref.read(layerControllerProvider).zoomToLayer(layer.id);
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.delete, color: Colors.red),
            title: const Text('削除', style: TextStyle(color: Colors.red)),
            onTap: () {
              Navigator.pop(context);
              _confirmDelete(context);
            },
          ),
        ],
      ),
    );
  }

  void _showRenameDialog(BuildContext context) {
    final controller = TextEditingController(text: widget.layer.name);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('レイヤー名を変更'),
        content: TextField(
          controller: controller,
          autofocus: true,
          decoration: const InputDecoration(
            labelText: 'レイヤー名',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('キャンセル'),
          ),
          ElevatedButton(
            onPressed: () {
              // 名前変更処理
              Navigator.pop(context);
            },
            child: const Text('変更'),
          ),
        ],
      ),
    );
  }

  void _confirmDelete(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('レイヤーを削除'),
        content: Text('「${widget.layer.name}」を削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('キャンセル'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () {
              Navigator.pop(context);
              ref.read(layerControllerProvider).removeLayer(widget.layer.id);
            },
            child: const Text('削除'),
          ),
        ],
      ),
    );
  }
}
```

## 技術的な考慮事項

1. **パフォーマンス**
   - 多数のレイヤーがある場合のリスト表示最適化
   - 不透明度変更時のリアルタイムプレビュー

2. **3D Tilesの制限**
   - 3D Tilesのスタイル変更はCesium固有の制限がある
   - 一部のスタイルオプションは再読み込みが必要な場合がある

3. **座標系の整合**
   - 複数レイヤーを重ねる際の座標系の整合性確認
   - 地形との高さ関係の調整

## 成果物・完了条件

- [ ] レイヤーの追加・削除が動作する
- [ ] レイヤーの表示/非表示切り替えが動作する
- [ ] 不透明度スライダーが動作する
- [ ] レイヤーのロック/アンロックが動作する
- [ ] ドラッグ&ドロップで順序変更ができる
- [ ] 点群のスタイル設定（点サイズ、色モード）が動作する
- [ ] レイヤーへのズームが動作する

## 次工程への引き継ぎ事項

- アセット配置はレイヤーとして管理（工程09）
- 計測結果もレイヤーとして管理（工程10）
- レイヤー設定はプロジェクト保存時に `project.json` に含める
