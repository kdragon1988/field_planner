# 工程04: ベースマップ統合

## 目的・概要

Cesium imagery、Google Maps API、OpenStreetMap等のベースマップをCesiumJS上に統合し、ユーザーがベースマップを選択・切り替えできる機能を実装する。複数レイヤーの重畳、透過設定も対応する。

## 対応する機能要件

- FR-20: ベースマップ選択（Cesium imagery / Google Maps / OSM等）
- FR-21: 複数レイヤー重畳（透過、順序）
- FR-22: 2D/3D表示切替

## 実装タスク詳細

### 1. ベースマップ設定データモデル

```dart
// lib/data/models/basemap_config.dart

/// ベースマッププロバイダ種別
enum BaseMapProvider {
  /// Cesium Ion World Imagery
  cesiumIon('Cesium Ion', 'cesium_ion'),
  
  /// Bing Maps Aerial
  bingAerial('Bing Aerial', 'bing_aerial'),
  
  /// Bing Maps with Labels
  bingAerialLabels('Bing Aerial + Labels', 'bing_aerial_labels'),
  
  /// Bing Maps Roads
  bingRoads('Bing Roads', 'bing_roads'),
  
  /// OpenStreetMap
  osm('OpenStreetMap', 'osm'),
  
  /// ESRI World Imagery
  esriWorldImagery('ESRI World Imagery', 'esri_world'),
  
  /// ESRI National Geographic
  esriNatGeo('ESRI National Geographic', 'esri_natgeo'),
  
  /// Google Maps (要APIキー)
  googleMaps('Google Maps', 'google_maps'),
  
  /// Google Satellite (要APIキー)
  googleSatellite('Google Satellite', 'google_satellite'),
  
  /// Google Hybrid (要APIキー)
  googleHybrid('Google Hybrid', 'google_hybrid'),
  
  /// カスタムタイルURL
  custom('Custom Tiles', 'custom');

  final String displayName;
  final String id;
  
  const BaseMapProvider(this.displayName, this.id);
}

/// ベースマップレイヤー設定
@freezed
class BaseMapLayerConfig with _$BaseMapLayerConfig {
  const factory BaseMapLayerConfig({
    required String id,
    required BaseMapProvider provider,
    @Default(true) bool visible,
    @Default(1.0) double opacity,
    @Default(0) int order,
    String? customUrl,
    String? apiKey,
    Map<String, dynamic>? additionalOptions,
  }) = _BaseMapLayerConfig;

  factory BaseMapLayerConfig.fromJson(Map<String, dynamic> json) => 
      _$BaseMapLayerConfigFromJson(json);
}
```

### 2. APIキー管理サービス

```dart
// lib/data/services/api_key_service.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

/// APIキー管理サービス
/// 
/// 各種マップサービスのAPIキーを安全に保存・取得する
class ApiKeyService {
  static const String _bingKeyName = 'bing_maps_api_key';
  static const String _googleKeyName = 'google_maps_api_key';
  static const String _cesiumKeyName = 'cesium_ion_token';
  
  final FlutterSecureStorage _storage;

  ApiKeyService() : _storage = const FlutterSecureStorage(
    aOptions: AndroidOptions(encryptedSharedPreferences: true),
    iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
  );

  /// Bing Maps APIキーを取得
  Future<String?> getBingMapsApiKey() async {
    return await _storage.read(key: _bingKeyName);
  }

  /// Bing Maps APIキーを保存
  Future<void> setBingMapsApiKey(String apiKey) async {
    await _storage.write(key: _bingKeyName, value: apiKey);
  }

  /// Google Maps APIキーを取得
  Future<String?> getGoogleMapsApiKey() async {
    return await _storage.read(key: _googleKeyName);
  }

  /// Google Maps APIキーを保存
  Future<void> setGoogleMapsApiKey(String apiKey) async {
    await _storage.write(key: _googleKeyName, value: apiKey);
  }

  /// Cesium Ion トークンを取得
  Future<String?> getCesiumIonToken() async {
    return await _storage.read(key: _cesiumKeyName);
  }

  /// Cesium Ion トークンを保存
  Future<void> setCesiumIonToken(String token) async {
    await _storage.write(key: _cesiumKeyName, value: token);
  }

  /// APIキーが設定されているか確認
  Future<Map<String, bool>> checkApiKeyStatus() async {
    return {
      'bing': (await getBingMapsApiKey())?.isNotEmpty ?? false,
      'google': (await getGoogleMapsApiKey())?.isNotEmpty ?? false,
      'cesium': (await getCesiumIonToken())?.isNotEmpty ?? false,
    };
  }

  /// 全APIキーを削除
  Future<void> clearAllKeys() async {
    await _storage.deleteAll();
  }
}
```

### 3. cesium_bridge.js ベースマップ拡張

```javascript
// assets/cesium/cesium_bridge.js に追加

/**
 * ベースマップ管理
 */
const baseMapLayers = new Map();

/**
 * ベースマッププロバイダを追加
 * @param {Object} config - レイヤー設定
 */
function addBaseMapLayer(config) {
  let imageryProvider;
  
  switch (config.provider) {
    case 'cesium_ion':
      imageryProvider = new Cesium.IonImageryProvider({
        assetId: 2 // Cesium World Imagery
      });
      break;
      
    case 'bing_aerial':
      imageryProvider = new Cesium.BingMapsImageryProvider({
        url: 'https://dev.virtualearth.net',
        key: config.apiKey || '',
        mapStyle: Cesium.BingMapsStyle.AERIAL
      });
      break;
      
    case 'bing_aerial_labels':
      imageryProvider = new Cesium.BingMapsImageryProvider({
        url: 'https://dev.virtualearth.net',
        key: config.apiKey || '',
        mapStyle: Cesium.BingMapsStyle.AERIAL_WITH_LABELS
      });
      break;
      
    case 'bing_roads':
      imageryProvider = new Cesium.BingMapsImageryProvider({
        url: 'https://dev.virtualearth.net',
        key: config.apiKey || '',
        mapStyle: Cesium.BingMapsStyle.ROAD
      });
      break;
      
    case 'osm':
      imageryProvider = new Cesium.OpenStreetMapImageryProvider({
        url: 'https://a.tile.openstreetmap.org/'
      });
      break;
      
    case 'esri_world':
      imageryProvider = new Cesium.ArcGisMapServerImageryProvider({
        url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
      });
      break;
      
    case 'esri_natgeo':
      imageryProvider = new Cesium.ArcGisMapServerImageryProvider({
        url: 'https://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer'
      });
      break;
      
    case 'google_maps':
    case 'google_satellite':
    case 'google_hybrid':
      // Google Maps は UrlTemplateImageryProvider で対応
      // 注意: Google Maps Platform利用規約の遵守が必要
      const googleMapTypes = {
        'google_maps': 'm',      // roadmap
        'google_satellite': 's', // satellite
        'google_hybrid': 'y'     // hybrid
      };
      imageryProvider = new Cesium.UrlTemplateImageryProvider({
        url: `https://mt1.google.com/vt/lyrs=${googleMapTypes[config.provider]}&x={x}&y={y}&z={z}`,
        credit: 'Map data ©2024 Google'
      });
      break;
      
    case 'custom':
      if (config.customUrl) {
        imageryProvider = new Cesium.UrlTemplateImageryProvider({
          url: config.customUrl,
          credit: config.credit || ''
        });
      }
      break;
      
    default:
      console.warn('Unknown provider:', config.provider);
      return;
  }
  
  if (imageryProvider) {
    const layer = viewer.imageryLayers.addImageryProvider(imageryProvider);
    layer.alpha = config.opacity !== undefined ? config.opacity : 1.0;
    layer.show = config.visible !== undefined ? config.visible : true;
    
    baseMapLayers.set(config.id, layer);
    
    sendToFlutter('baseMapLayerAdded', { id: config.id });
  }
}

/**
 * ベースマップレイヤーを削除
 * @param {string} layerId - レイヤーID
 */
function removeBaseMapLayer(layerId) {
  const layer = baseMapLayers.get(layerId);
  if (layer) {
    viewer.imageryLayers.remove(layer);
    baseMapLayers.delete(layerId);
  }
}

/**
 * ベースマップの透明度を設定
 * @param {string} layerId - レイヤーID
 * @param {number} opacity - 透明度 (0-1)
 */
function setBaseMapOpacity(layerId, opacity) {
  const layer = baseMapLayers.get(layerId);
  if (layer) {
    layer.alpha = opacity;
  }
}

/**
 * ベースマップの表示/非表示を切り替え
 * @param {string} layerId - レイヤーID
 * @param {boolean} visible - 表示フラグ
 */
function setBaseMapVisible(layerId, visible) {
  const layer = baseMapLayers.get(layerId);
  if (layer) {
    layer.show = visible;
  }
}

/**
 * ベースマップの順序を変更
 * @param {string} layerId - レイヤーID
 * @param {number} index - 新しいインデックス
 */
function setBaseMapOrder(layerId, index) {
  const layer = baseMapLayers.get(layerId);
  if (layer) {
    const currentIndex = viewer.imageryLayers.indexOf(layer);
    if (currentIndex !== index) {
      viewer.imageryLayers.remove(layer, false);
      viewer.imageryLayers.add(layer, index);
    }
  }
}

/**
 * 全ベースマップを削除
 */
function clearAllBaseMaps() {
  for (const [id, layer] of baseMapLayers) {
    viewer.imageryLayers.remove(layer);
  }
  baseMapLayers.clear();
}

// handleFlutterMessage に追加
function handleFlutterMessage(method, params) {
  switch (method) {
    // ... 既存のcase
    
    case 'addBaseMapLayer':
      addBaseMapLayer(params);
      break;
    case 'removeBaseMapLayer':
      removeBaseMapLayer(params.layerId);
      break;
    case 'setBaseMapOpacity':
      setBaseMapOpacity(params.layerId, params.opacity);
      break;
    case 'setBaseMapVisible':
      setBaseMapVisible(params.layerId, params.visible);
      break;
    case 'setBaseMapOrder':
      setBaseMapOrder(params.layerId, params.index);
      break;
    case 'clearAllBaseMaps':
      clearAllBaseMaps();
      break;
  }
}
```

### 4. Flutter側 BaseMapController

```dart
// lib/infrastructure/webview/basemap_controller.dart

/// ベースマップ管理コントローラ
/// 
/// CesiumJSのベースマップレイヤーを管理する
class BaseMapController {
  final CesiumController _cesiumController;
  final ApiKeyService _apiKeyService;
  
  final List<BaseMapLayerConfig> _layers = [];
  
  List<BaseMapLayerConfig> get layers => List.unmodifiable(_layers);

  BaseMapController(this._cesiumController, this._apiKeyService);

  /// ベースマップレイヤーを追加
  Future<void> addLayer(BaseMapLayerConfig config) async {
    // APIキーが必要なプロバイダの場合、キーを取得
    String? apiKey;
    if (_requiresApiKey(config.provider)) {
      apiKey = await _getApiKeyForProvider(config.provider);
      if (apiKey == null || apiKey.isEmpty) {
        throw BaseMapException(
          'APIキーが設定されていません: ${config.provider.displayName}',
          provider: config.provider,
        );
      }
    }
    
    final configWithKey = config.copyWith(apiKey: apiKey);
    
    await _cesiumController.executeMethod('addBaseMapLayer', {
      'id': configWithKey.id,
      'provider': configWithKey.provider.id,
      'opacity': configWithKey.opacity,
      'visible': configWithKey.visible,
      'apiKey': configWithKey.apiKey,
      'customUrl': configWithKey.customUrl,
    });
    
    _layers.add(configWithKey);
  }

  /// ベースマップレイヤーを削除
  Future<void> removeLayer(String layerId) async {
    await _cesiumController.executeMethod('removeBaseMapLayer', {
      'layerId': layerId,
    });
    _layers.removeWhere((l) => l.id == layerId);
  }

  /// 透明度を設定
  Future<void> setOpacity(String layerId, double opacity) async {
    await _cesiumController.executeMethod('setBaseMapOpacity', {
      'layerId': layerId,
      'opacity': opacity.clamp(0.0, 1.0),
    });
    
    final index = _layers.indexWhere((l) => l.id == layerId);
    if (index != -1) {
      _layers[index] = _layers[index].copyWith(opacity: opacity);
    }
  }

  /// 表示/非表示を切り替え
  Future<void> setVisible(String layerId, bool visible) async {
    await _cesiumController.executeMethod('setBaseMapVisible', {
      'layerId': layerId,
      'visible': visible,
    });
    
    final index = _layers.indexWhere((l) => l.id == layerId);
    if (index != -1) {
      _layers[index] = _layers[index].copyWith(visible: visible);
    }
  }

  /// デフォルトのベースマップを設定
  Future<void> setDefaultBaseMap(BaseMapProvider provider) async {
    await clearAll();
    await addLayer(BaseMapLayerConfig(
      id: 'default_basemap',
      provider: provider,
    ));
  }

  /// 全レイヤーをクリア
  Future<void> clearAll() async {
    await _cesiumController.executeMethod('clearAllBaseMaps', {});
    _layers.clear();
  }

  bool _requiresApiKey(BaseMapProvider provider) {
    return [
      BaseMapProvider.bingAerial,
      BaseMapProvider.bingAerialLabels,
      BaseMapProvider.bingRoads,
      BaseMapProvider.googleMaps,
      BaseMapProvider.googleSatellite,
      BaseMapProvider.googleHybrid,
      BaseMapProvider.cesiumIon,
    ].contains(provider);
  }

  Future<String?> _getApiKeyForProvider(BaseMapProvider provider) async {
    switch (provider) {
      case BaseMapProvider.bingAerial:
      case BaseMapProvider.bingAerialLabels:
      case BaseMapProvider.bingRoads:
        return await _apiKeyService.getBingMapsApiKey();
      case BaseMapProvider.googleMaps:
      case BaseMapProvider.googleSatellite:
      case BaseMapProvider.googleHybrid:
        return await _apiKeyService.getGoogleMapsApiKey();
      case BaseMapProvider.cesiumIon:
        return await _apiKeyService.getCesiumIonToken();
      default:
        return null;
    }
  }
}

/// ベースマップ例外
class BaseMapException implements Exception {
  final String message;
  final BaseMapProvider? provider;

  BaseMapException(this.message, {this.provider});

  @override
  String toString() => 'BaseMapException: $message';
}
```

### 5. ベースマップ選択UI

```dart
// lib/presentation/widgets/basemap_selector.dart

import 'package:flutter/material.dart';

/// ベースマップ選択ダイアログ
class BaseMapSelectorDialog extends StatefulWidget {
  final BaseMapProvider currentProvider;
  final Map<String, bool> apiKeyStatus;
  final Function(BaseMapProvider) onSelect;

  const BaseMapSelectorDialog({
    super.key,
    required this.currentProvider,
    required this.apiKeyStatus,
    required this.onSelect,
  });

  @override
  State<BaseMapSelectorDialog> createState() => _BaseMapSelectorDialogState();
}

class _BaseMapSelectorDialogState extends State<BaseMapSelectorDialog> {
  late BaseMapProvider _selectedProvider;

  @override
  void initState() {
    super.initState();
    _selectedProvider = widget.currentProvider;
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('ベースマップを選択'),
      content: SizedBox(
        width: 400,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildCategory('無料', [
              BaseMapProvider.osm,
              BaseMapProvider.esriWorldImagery,
              BaseMapProvider.esriNatGeo,
            ]),
            const Divider(),
            _buildCategory('Bing Maps（APIキー必要）', [
              BaseMapProvider.bingAerial,
              BaseMapProvider.bingAerialLabels,
              BaseMapProvider.bingRoads,
            ], requiresKey: 'bing'),
            const Divider(),
            _buildCategory('Google Maps（APIキー必要）', [
              BaseMapProvider.googleMaps,
              BaseMapProvider.googleSatellite,
              BaseMapProvider.googleHybrid,
            ], requiresKey: 'google'),
            const Divider(),
            _buildCategory('Cesium Ion（トークン必要）', [
              BaseMapProvider.cesiumIon,
            ], requiresKey: 'cesium'),
            const Divider(),
            _buildCustomOption(),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('キャンセル'),
        ),
        ElevatedButton(
          onPressed: () {
            widget.onSelect(_selectedProvider);
            Navigator.pop(context);
          },
          child: const Text('適用'),
        ),
      ],
    );
  }

  Widget _buildCategory(
    String title,
    List<BaseMapProvider> providers, {
    String? requiresKey,
  }) {
    final hasKey = requiresKey == null || 
        (widget.apiKeyStatus[requiresKey] ?? false);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
            if (!hasKey) ...[
              const SizedBox(width: 8),
              const Icon(Icons.warning, color: Colors.orange, size: 16),
              const Text(' 未設定', style: TextStyle(color: Colors.orange, fontSize: 12)),
            ],
          ],
        ),
        const SizedBox(height: 8),
        ...providers.map((p) => _buildProviderTile(p, enabled: hasKey)),
      ],
    );
  }

  Widget _buildProviderTile(BaseMapProvider provider, {bool enabled = true}) {
    return RadioListTile<BaseMapProvider>(
      title: Text(provider.displayName),
      value: provider,
      groupValue: _selectedProvider,
      onChanged: enabled
          ? (value) => setState(() => _selectedProvider = value!)
          : null,
      dense: true,
    );
  }

  Widget _buildCustomOption() {
    return ListTile(
      leading: Radio<BaseMapProvider>(
        value: BaseMapProvider.custom,
        groupValue: _selectedProvider,
        onChanged: (value) => setState(() => _selectedProvider = value!),
      ),
      title: const Text('カスタムタイルURL'),
      subtitle: _selectedProvider == BaseMapProvider.custom
          ? TextField(
              decoration: const InputDecoration(
                hintText: 'https://example.com/tiles/{z}/{x}/{y}.png',
              ),
            )
          : null,
    );
  }
}
```

### 6. APIキー設定画面

```dart
// lib/presentation/screens/settings/api_keys_settings_screen.dart

/// APIキー設定画面
class ApiKeysSettingsScreen extends StatefulWidget {
  const ApiKeysSettingsScreen({super.key});

  @override
  State<ApiKeysSettingsScreen> createState() => _ApiKeysSettingsScreenState();
}

class _ApiKeysSettingsScreenState extends State<ApiKeysSettingsScreen> {
  final _bingController = TextEditingController();
  final _googleController = TextEditingController();
  final _cesiumController = TextEditingController();
  
  bool _isLoading = true;
  bool _showKeys = false;

  @override
  void initState() {
    super.initState();
    _loadKeys();
  }

  Future<void> _loadKeys() async {
    final apiKeyService = ApiKeyService();
    _bingController.text = await apiKeyService.getBingMapsApiKey() ?? '';
    _googleController.text = await apiKeyService.getGoogleMapsApiKey() ?? '';
    _cesiumController.text = await apiKeyService.getCesiumIonToken() ?? '';
    setState(() => _isLoading = false);
  }

  Future<void> _saveKeys() async {
    final apiKeyService = ApiKeyService();
    await apiKeyService.setBingMapsApiKey(_bingController.text);
    await apiKeyService.setGoogleMapsApiKey(_googleController.text);
    await apiKeyService.setCesiumIonToken(_cesiumController.text);
    
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('APIキーを保存しました')),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Text('APIキー設定', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              const Spacer(),
              IconButton(
                icon: Icon(_showKeys ? Icons.visibility_off : Icons.visibility),
                onPressed: () => setState(() => _showKeys = !_showKeys),
                tooltip: _showKeys ? 'キーを隠す' : 'キーを表示',
              ),
            ],
          ),
          const SizedBox(height: 16),
          const Text(
            '注意: APIキーは安全に保存されますが、利用規約と課金に注意してください。',
            style: TextStyle(color: Colors.orange),
          ),
          const SizedBox(height: 24),
          _buildKeyField(
            label: 'Bing Maps API Key',
            controller: _bingController,
            hint: 'Bing Maps Dev Centerで取得',
            helpUrl: 'https://www.bingmapsportal.com/',
          ),
          const SizedBox(height: 16),
          _buildKeyField(
            label: 'Google Maps API Key',
            controller: _googleController,
            hint: 'Google Cloud Consoleで取得',
            helpUrl: 'https://console.cloud.google.com/',
          ),
          const SizedBox(height: 16),
          _buildKeyField(
            label: 'Cesium Ion Access Token',
            controller: _cesiumController,
            hint: 'Cesium Ionで取得',
            helpUrl: 'https://cesium.com/ion/',
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: _saveKeys,
            icon: const Icon(Icons.save),
            label: const Text('保存'),
          ),
        ],
      ),
    );
  }

  Widget _buildKeyField({
    required String label,
    required TextEditingController controller,
    required String hint,
    required String helpUrl,
  }) {
    return Row(
      children: [
        Expanded(
          child: TextField(
            controller: controller,
            obscureText: !_showKeys,
            decoration: InputDecoration(
              labelText: label,
              hintText: hint,
              border: const OutlineInputBorder(),
            ),
          ),
        ),
        const SizedBox(width: 8),
        IconButton(
          icon: const Icon(Icons.help_outline),
          onPressed: () => _launchUrl(helpUrl),
          tooltip: '取得方法を見る',
        ),
      ],
    );
  }

  void _launchUrl(String url) {
    // URL起動処理
  }

  @override
  void dispose() {
    _bingController.dispose();
    _googleController.dispose();
    _cesiumController.dispose();
    super.dispose();
  }
}
```

## 技術的な考慮事項

1. **Google Maps利用規約**
   - Maps JavaScript APIの利用規約を遵守
   - オフラインキャッシュは規約上禁止されている可能性があるため要確認
   - 表示時は適切な帰属表示（attribution）が必要

2. **APIキーのセキュリティ**
   - Flutter Secure Storageで暗号化保存
   - ログ出力時にAPIキーをマスク
   - 共有エクスポート時にAPIキーは含めない

3. **パフォーマンス**
   - タイル読み込みは非同期で行い、UIをブロックしない
   - 複数レイヤー重畳時の描画負荷を考慮

4. **オフライン対応**
   - OSMやESRIはオフライン利用不可（オンライン前提）
   - ネットワーク切断時のエラーハンドリング

## 成果物・完了条件

- [ ] OSM、ESRI等の無料ベースマップが表示できる
- [ ] Bing Maps がAPIキー設定後に表示できる
- [ ] Google Maps がAPIキー設定後に表示できる
- [ ] 複数レイヤーの重畳ができる
- [ ] 透明度調整が動作する
- [ ] APIキーの安全な保存・取得ができる
- [ ] ベースマップ選択UIが動作する

## 次工程への引き継ぎ事項

- ベースマップ設定はプロジェクト保存時に `project.json` に含める
- 3Dデータレイヤーとベースマップの重ね合わせは工程07で調整
