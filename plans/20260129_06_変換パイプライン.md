# 工程06: データ変換パイプライン

## 目的・概要

インポートされた点群・メッシュデータをCesiumで高速に表示できる3D Tiles形式に変換するローカル変換パイプラインを構築する。PDAL/Entwineを使用した点群変換、メッシュの3D Tiles変換、バックグラウンドジョブ管理を実装する。

## 対応する機能要件

- FR-11: 表示最適化（点群のダウンサンプル/LOD、3D Tiles化によるストリーミング表示）
- NFR-01: 10M点規模の点群はタイル化/LOD化後に快適表示
- NFR-30: 変換処理をモジュール化

## 実装タスク詳細

### 1. 変換パイプラインアーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Conversion Pipeline                               │
│                                                                      │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐             │
│  │   Input     │    │  Converter  │    │   Output    │             │
│  │   Files     │───▶│   Engine    │───▶│  3D Tiles   │             │
│  └─────────────┘    └─────────────┘    └─────────────┘             │
│        │                  │                   │                      │
│        │                  │                   │                      │
│  ┌─────┴─────┐      ┌─────┴─────┐      ┌─────┴─────┐               │
│  │ LAS/LAZ   │      │   PDAL    │      │  pnts     │               │
│  │ PLY       │      │  Entwine  │      │  b3dm     │               │
│  │ OBJ/FBX   │      │  gltf-pack│      │  tileset  │               │
│  │ glTF/GLB  │      │           │      │  .json    │               │
│  └───────────┘      └───────────┘      └───────────┘               │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                    Job Manager                               │    │
│  │  - Queue management                                          │    │
│  │  - Progress tracking                                         │    │
│  │  - Cancellation                                              │    │
│  │  - Error handling                                            │    │
│  └─────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
```

### 2. 変換エンジンインターフェース

```dart
// lib/infrastructure/converters/converter_interface.dart

/// 変換エンジンインターフェース
/// 
/// 各種フォーマットの変換処理を抽象化
abstract class ConverterEngine {
  /// サポートする入力フォーマット
  List<ImportFormat> get supportedFormats;
  
  /// 変換を実行
  /// 
  /// [inputPath] 入力ファイルパス
  /// [outputDir] 出力ディレクトリ
  /// [options] 変換オプション
  /// [onProgress] 進捗コールバック (0.0-1.0)
  /// 
  /// Returns: 生成されたtileset.jsonのパス
  Future<String> convert({
    required String inputPath,
    required String outputDir,
    ConversionOptions? options,
    void Function(double progress, String message)? onProgress,
    CancellationToken? cancellationToken,
  });
  
  /// 変換をキャンセル
  Future<void> cancel();
  
  /// 変換が可能か検証
  Future<ConversionValidation> validate(String inputPath);
}

/// 変換オプション
class ConversionOptions {
  /// 点群のダウンサンプリング率 (0.0-1.0)
  final double downsampleRatio;
  
  /// 最大LODレベル
  final int maxLodLevel;
  
  /// タイルの最大サイズ（点数）
  final int maxPointsPerTile;
  
  /// 座標系 (EPSG)
  final int? sourceEpsg;
  
  /// 出力座標系
  final int targetEpsg;
  
  /// テクスチャ圧縮
  final bool compressTextures;
  
  /// Draco圧縮（メッシュ用）
  final bool dracoCompression;

  const ConversionOptions({
    this.downsampleRatio = 1.0,
    this.maxLodLevel = 16,
    this.maxPointsPerTile = 50000,
    this.sourceEpsg,
    this.targetEpsg = 4326,
    this.compressTextures = true,
    this.dracoCompression = true,
  });
}

/// 変換検証結果
class ConversionValidation {
  final bool isValid;
  final List<String> errors;
  final List<String> warnings;
  final int? estimatedPointCount;
  final int? estimatedDurationSeconds;

  ConversionValidation({
    required this.isValid,
    this.errors = const [],
    this.warnings = const [],
    this.estimatedPointCount,
    this.estimatedDurationSeconds,
  });
}

/// キャンセルトークン
class CancellationToken {
  bool _isCancelled = false;
  
  bool get isCancelled => _isCancelled;
  
  void cancel() => _isCancelled = true;
}
```

### 3. 点群変換エンジン（PDAL/Entwine）

```dart
// lib/infrastructure/converters/pointcloud_converter.dart

import 'dart:io';
import 'dart:convert';

/// 点群変換エンジン
/// 
/// PDAL/Entwineを使用してLAS/LAZ/PLYを3D Tilesに変換
class PointCloudConverter implements ConverterEngine {
  static const String pdalPath = 'pdal'; // パスまたは同梱バイナリ
  static const String entwisePath = 'entwine';
  
  Process? _currentProcess;
  
  @override
  List<ImportFormat> get supportedFormats => [
    ImportFormat.las,
    ImportFormat.laz,
    ImportFormat.plyPoints,
    ImportFormat.e57,
  ];

  @override
  Future<String> convert({
    required String inputPath,
    required String outputDir,
    ConversionOptions? options,
    void Function(double progress, String message)? onProgress,
    CancellationToken? cancellationToken,
  }) async {
    options ??= const ConversionOptions();
    
    // 出力ディレクトリ作成
    final eptDir = path.join(outputDir, 'ept');
    final tilesDir = path.join(outputDir, '3dtiles');
    await Directory(eptDir).create(recursive: true);
    await Directory(tilesDir).create(recursive: true);
    
    // Step 1: PDAL pipeline でダウンサンプリング・座標変換
    onProgress?.call(0.1, 'PDALで前処理中...');
    final preprocessedPath = await _preprocessWithPdal(
      inputPath, 
      outputDir, 
      options,
      cancellationToken,
    );
    
    if (cancellationToken?.isCancelled ?? false) {
      throw ConversionCancelledException();
    }
    
    // Step 2: Entwine でEPT生成
    onProgress?.call(0.4, 'Entwineでタイル化中...');
    await _runEntwine(preprocessedPath, eptDir, cancellationToken);
    
    if (cancellationToken?.isCancelled ?? false) {
      throw ConversionCancelledException();
    }
    
    // Step 3: EPT to 3D Tiles変換
    onProgress?.call(0.8, '3D Tiles生成中...');
    final tilesetPath = await _convertEptTo3DTiles(eptDir, tilesDir);
    
    onProgress?.call(1.0, '変換完了');
    
    return tilesetPath;
  }

  @override
  Future<void> cancel() async {
    _currentProcess?.kill();
  }

  @override
  Future<ConversionValidation> validate(String inputPath) async {
    final errors = <String>[];
    final warnings = <String>[];
    
    // ファイル存在確認
    if (!await File(inputPath).exists()) {
      errors.add('ファイルが見つかりません: $inputPath');
      return ConversionValidation(isValid: false, errors: errors);
    }
    
    // PDAL利用可能確認
    try {
      final result = await Process.run(pdalPath, ['--version']);
      if (result.exitCode != 0) {
        errors.add('PDALが利用できません');
      }
    } catch (e) {
      errors.add('PDALが見つかりません。インストールが必要です。');
    }
    
    // ファイルサイズ確認
    final fileSize = await File(inputPath).length();
    final fileSizeGB = fileSize / (1024 * 1024 * 1024);
    if (fileSizeGB > 10) {
      warnings.add('ファイルサイズが大きいため、変換に時間がかかる場合があります (${fileSizeGB.toStringAsFixed(1)} GB)');
    }
    
    // 点数推定
    final analyzer = FileAnalyzerService();
    final pointCount = await analyzer.estimatePointCount(inputPath);
    
    // 所要時間推定（大まかな目安）
    int? estimatedSeconds;
    if (pointCount != null) {
      // 約100万点/分として推定
      estimatedSeconds = (pointCount / 1000000 * 60).ceil();
    }
    
    return ConversionValidation(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
      estimatedPointCount: pointCount,
      estimatedDurationSeconds: estimatedSeconds,
    );
  }

  /// PDALで前処理（ダウンサンプリング、座標変換）
  Future<String> _preprocessWithPdal(
    String inputPath,
    String outputDir,
    ConversionOptions options,
    CancellationToken? cancellationToken,
  ) async {
    final outputPath = path.join(outputDir, 'preprocessed.las');
    
    // PDALパイプライン設定
    final pipeline = {
      'pipeline': [
        inputPath,
        // ダウンサンプリング
        if (options.downsampleRatio < 1.0) {
          'type': 'filters.sample',
          'radius': (1.0 / options.downsampleRatio).toString(),
        },
        // 座標系変換
        if (options.sourceEpsg != null) {
          'type': 'filters.reprojection',
          'in_srs': 'EPSG:${options.sourceEpsg}',
          'out_srs': 'EPSG:${options.targetEpsg}',
        },
        outputPath,
      ],
    };
    
    final pipelineFile = path.join(outputDir, 'pipeline.json');
    await File(pipelineFile).writeAsString(jsonEncode(pipeline));
    
    _currentProcess = await Process.start(
      pdalPath,
      ['pipeline', pipelineFile],
    );
    
    final exitCode = await _currentProcess!.exitCode;
    
    if (cancellationToken?.isCancelled ?? false) {
      throw ConversionCancelledException();
    }
    
    if (exitCode != 0) {
      final stderr = await _currentProcess!.stderr.transform(utf8.decoder).join();
      throw ConversionException('PDAL処理に失敗しました: $stderr');
    }
    
    return outputPath;
  }

  /// Entwineでタイル化
  Future<void> _runEntwine(
    String inputPath,
    String outputDir,
    CancellationToken? cancellationToken,
  ) async {
    _currentProcess = await Process.start(
      entwisePath,
      ['build', '-i', inputPath, '-o', outputDir],
    );
    
    final exitCode = await _currentProcess!.exitCode;
    
    if (cancellationToken?.isCancelled ?? false) {
      throw ConversionCancelledException();
    }
    
    if (exitCode != 0) {
      final stderr = await _currentProcess!.stderr.transform(utf8.decoder).join();
      throw ConversionException('Entwine処理に失敗しました: $stderr');
    }
  }

  /// EPT→3D Tiles変換
  Future<String> _convertEptTo3DTiles(String eptDir, String tilesDir) async {
    // EPTからCesium 3D Tiles Point Cloud形式への変換
    // ept-tileset.jsonを3D Tiles tileset.jsonに変換
    
    final eptTilesetPath = path.join(eptDir, 'ept-tileset.json');
    if (!await File(eptTilesetPath).exists()) {
      throw ConversionException('EPT tileset.json が見つかりません');
    }
    
    // シンプルなtileset.jsonを生成
    // 実際のアプリではept-to-3dtiles等のツールを使用
    final tilesetPath = path.join(tilesDir, 'tileset.json');
    
    final tileset = {
      'asset': {
        'version': '1.0',
        'tilesetVersion': '1.0.0',
      },
      'geometricError': 1000,
      'root': {
        'boundingVolume': {
          'region': [0, 0, 0, 0, 0, 100] // 実際はEPTから取得
        },
        'geometricError': 100,
        'refine': 'ADD',
        'content': {
          'uri': 'root.pnts'
        },
        'children': []
      }
    };
    
    await File(tilesetPath).writeAsString(jsonEncode(tileset));
    
    return tilesetPath;
  }
}

/// 変換例外
class ConversionException implements Exception {
  final String message;
  ConversionException(this.message);
  
  @override
  String toString() => 'ConversionException: $message';
}

/// 変換キャンセル例外
class ConversionCancelledException implements Exception {
  @override
  String toString() => '変換がキャンセルされました';
}
```

### 4. メッシュ変換エンジン

```dart
// lib/infrastructure/converters/mesh_converter.dart

/// メッシュ変換エンジン
/// 
/// OBJ/FBX/glTFを3D Tiles (B3DM)に変換
class MeshConverter implements ConverterEngine {
  Process? _currentProcess;
  
  @override
  List<ImportFormat> get supportedFormats => [
    ImportFormat.obj,
    ImportFormat.fbx,
    ImportFormat.gltf,
    ImportFormat.glb,
  ];

  @override
  Future<String> convert({
    required String inputPath,
    required String outputDir,
    ConversionOptions? options,
    void Function(double progress, String message)? onProgress,
    CancellationToken? cancellationToken,
  }) async {
    options ??= const ConversionOptions();
    final ext = path.extension(inputPath).toLowerCase();
    
    // Step 1: glTF/GLBに統一
    onProgress?.call(0.2, 'glTF形式に変換中...');
    String glbPath;
    
    if (ext == '.glb' || ext == '.gltf') {
      glbPath = inputPath;
    } else {
      glbPath = await _convertToGlb(inputPath, outputDir, options);
    }
    
    if (cancellationToken?.isCancelled ?? false) {
      throw ConversionCancelledException();
    }
    
    // Step 2: Draco圧縮（オプション）
    if (options.dracoCompression) {
      onProgress?.call(0.5, 'Draco圧縮中...');
      glbPath = await _applyDracoCompression(glbPath, outputDir);
    }
    
    if (cancellationToken?.isCancelled ?? false) {
      throw ConversionCancelledException();
    }
    
    // Step 3: 3D Tiles (B3DM)生成
    onProgress?.call(0.8, '3D Tiles生成中...');
    final tilesetPath = await _generateB3dmTileset(glbPath, outputDir, options);
    
    onProgress?.call(1.0, '変換完了');
    
    return tilesetPath;
  }

  @override
  Future<void> cancel() async {
    _currentProcess?.kill();
  }

  @override
  Future<ConversionValidation> validate(String inputPath) async {
    final errors = <String>[];
    final warnings = <String>[];
    
    if (!await File(inputPath).exists()) {
      errors.add('ファイルが見つかりません: $inputPath');
    }
    
    final ext = path.extension(inputPath).toLowerCase();
    
    // OBJの場合、MTLファイルチェック
    if (ext == '.obj') {
      final mtlPath = inputPath.replaceAll('.obj', '.mtl');
      if (!await File(mtlPath).exists()) {
        warnings.add('MTLファイルが見つかりません。テクスチャなしで変換されます。');
      }
    }
    
    // FBXの場合
    if (ext == '.fbx') {
      warnings.add('FBX変換にはFBX SDKまたは互換ツールが必要です。');
    }
    
    return ConversionValidation(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
    );
  }

  /// OBJ/FBX → GLB変換
  Future<String> _convertToGlb(
    String inputPath,
    String outputDir,
    ConversionOptions options,
  ) async {
    final outputPath = path.join(outputDir, 'model.glb');
    final ext = path.extension(inputPath).toLowerCase();
    
    if (ext == '.obj') {
      // obj2gltf を使用（npm パッケージ）
      _currentProcess = await Process.start(
        'npx',
        ['obj2gltf', '-i', inputPath, '-o', outputPath, '--binary'],
      );
    } else if (ext == '.fbx') {
      // FBX2glTF を使用
      _currentProcess = await Process.start(
        'FBX2glTF',
        ['-i', inputPath, '-o', outputPath],
      );
    }
    
    final exitCode = await _currentProcess!.exitCode;
    if (exitCode != 0) {
      throw ConversionException('GLB変換に失敗しました');
    }
    
    return outputPath;
  }

  /// Draco圧縮を適用
  Future<String> _applyDracoCompression(String glbPath, String outputDir) async {
    final outputPath = path.join(outputDir, 'model_draco.glb');
    
    // gltf-pipeline を使用
    _currentProcess = await Process.start(
      'npx',
      ['gltf-pipeline', '-i', glbPath, '-o', outputPath, '-d'],
    );
    
    final exitCode = await _currentProcess!.exitCode;
    if (exitCode != 0) {
      // Draco圧縮失敗時は元ファイルを使用
      return glbPath;
    }
    
    return outputPath;
  }

  /// B3DM Tileset生成
  Future<String> _generateB3dmTileset(
    String glbPath,
    String outputDir,
    ConversionOptions options,
  ) async {
    // GLBをB3DMにラップ
    final glbBytes = await File(glbPath).readAsBytes();
    final b3dmBytes = _wrapGlbAsB3dm(glbBytes);
    
    final b3dmPath = path.join(outputDir, 'model.b3dm');
    await File(b3dmPath).writeAsBytes(b3dmBytes);
    
    // tileset.json生成
    final tilesetPath = path.join(outputDir, 'tileset.json');
    
    // バウンディングボックスを取得（GLBから解析）
    final boundingBox = await _extractBoundingBox(glbPath);
    
    final tileset = {
      'asset': {
        'version': '1.0',
        'tilesetVersion': '1.0.0',
      },
      'geometricError': 100,
      'root': {
        'boundingVolume': {
          'box': boundingBox,
        },
        'geometricError': 10,
        'refine': 'REPLACE',
        'content': {
          'uri': 'model.b3dm',
        },
      },
    };
    
    await File(tilesetPath).writeAsString(jsonEncode(tileset));
    
    return tilesetPath;
  }

  /// GLBをB3DM形式にラップ
  Uint8List _wrapGlbAsB3dm(Uint8List glbBytes) {
    // B3DM ヘッダ構造:
    // - magic: "b3dm" (4 bytes)
    // - version: 1 (4 bytes)
    // - byteLength: total size (4 bytes)
    // - featureTableJSONByteLength (4 bytes)
    // - featureTableBinaryByteLength (4 bytes)
    // - batchTableJSONByteLength (4 bytes)
    // - batchTableBinaryByteLength (4 bytes)
    // - glb data
    
    const headerSize = 28;
    final featureTableJson = '{"BATCH_LENGTH":0}';
    final featureTableBytes = utf8.encode(featureTableJson);
    final paddedLength = (featureTableBytes.length + 3) & ~3; // 4バイト境界
    
    final totalSize = headerSize + paddedLength + glbBytes.length;
    
    final buffer = ByteData(totalSize);
    var offset = 0;
    
    // Magic
    buffer.setUint8(offset++, 0x62); // b
    buffer.setUint8(offset++, 0x33); // 3
    buffer.setUint8(offset++, 0x64); // d
    buffer.setUint8(offset++, 0x6D); // m
    
    // Version
    buffer.setUint32(offset, 1, Endian.little);
    offset += 4;
    
    // Byte length
    buffer.setUint32(offset, totalSize, Endian.little);
    offset += 4;
    
    // Feature table JSON byte length
    buffer.setUint32(offset, paddedLength, Endian.little);
    offset += 4;
    
    // Feature table binary byte length
    buffer.setUint32(offset, 0, Endian.little);
    offset += 4;
    
    // Batch table JSON byte length
    buffer.setUint32(offset, 0, Endian.little);
    offset += 4;
    
    // Batch table binary byte length
    buffer.setUint32(offset, 0, Endian.little);
    offset += 4;
    
    // Feature table JSON
    final result = Uint8List(totalSize);
    result.setAll(0, buffer.buffer.asUint8List());
    result.setAll(headerSize, featureTableBytes);
    
    // Padding
    for (var i = featureTableBytes.length; i < paddedLength; i++) {
      result[headerSize + i] = 0x20; // space
    }
    
    // GLB data
    result.setAll(headerSize + paddedLength, glbBytes);
    
    return result;
  }

  Future<List<double>> _extractBoundingBox(String glbPath) async {
    // 簡易実装: デフォルトのバウンディングボックス
    // 実際はGLBからメッシュを解析して計算
    return [0, 0, 0, 10, 0, 0, 0, 10, 0, 0, 0, 10];
  }
}
```

### 5. 変換ジョブマネージャ

```dart
// lib/data/services/conversion_job_manager.dart

import 'dart:async';

/// 変換ジョブマネージャ
/// 
/// 複数の変換ジョブをキュー管理し、並列実行を制御
class ConversionJobManager {
  final Map<ImportFormat, ConverterEngine> _converters;
  final int _maxConcurrentJobs;
  
  final _jobQueue = <ConversionJob>[];
  final _activeJobs = <String, ConversionJob>{};
  final _completedJobs = <String, ConversionJob>{};
  
  final _jobStreamController = StreamController<ConversionJob>.broadcast();
  
  Stream<ConversionJob> get jobStream => _jobStreamController.stream;
  
  ConversionJobManager({
    required Map<ImportFormat, ConverterEngine> converters,
    int maxConcurrentJobs = 2,
  })  : _converters = converters,
        _maxConcurrentJobs = maxConcurrentJobs;

  /// ジョブを追加
  Future<ConversionJob> addJob({
    required String inputPath,
    required String outputDir,
    required ImportFormat format,
    ConversionOptions? options,
  }) async {
    final converter = _converters[format];
    if (converter == null) {
      throw UnsupportedFormatException(format.extension);
    }
    
    // 検証
    final validation = await converter.validate(inputPath);
    if (!validation.isValid) {
      throw ConversionException(validation.errors.join(', '));
    }
    
    final job = ConversionJob(
      id: const Uuid().v4(),
      inputPath: inputPath,
      outputDir: outputDir,
      format: format,
      options: options ?? const ConversionOptions(),
      status: ConversionJobStatus.queued,
      validation: validation,
    );
    
    _jobQueue.add(job);
    _notifyJobUpdate(job);
    
    // キュー処理を開始
    _processQueue();
    
    return job;
  }

  /// ジョブをキャンセル
  Future<void> cancelJob(String jobId) async {
    // キュー内のジョブをキャンセル
    final queueIndex = _jobQueue.indexWhere((j) => j.id == jobId);
    if (queueIndex != -1) {
      final job = _jobQueue.removeAt(queueIndex);
      _notifyJobUpdate(job.copyWith(status: ConversionJobStatus.cancelled));
      return;
    }
    
    // 実行中のジョブをキャンセル
    final activeJob = _activeJobs[jobId];
    if (activeJob != null) {
      activeJob.cancellationToken?.cancel();
      final converter = _converters[activeJob.format];
      await converter?.cancel();
    }
  }

  /// 全ジョブをキャンセル
  Future<void> cancelAllJobs() async {
    // キュー内のジョブをクリア
    for (final job in _jobQueue) {
      _notifyJobUpdate(job.copyWith(status: ConversionJobStatus.cancelled));
    }
    _jobQueue.clear();
    
    // 実行中のジョブをキャンセル
    for (final jobId in _activeJobs.keys.toList()) {
      await cancelJob(jobId);
    }
  }

  void _processQueue() {
    while (_activeJobs.length < _maxConcurrentJobs && _jobQueue.isNotEmpty) {
      final job = _jobQueue.removeAt(0);
      _startJob(job);
    }
  }

  Future<void> _startJob(ConversionJob job) async {
    final token = CancellationToken();
    var runningJob = job.copyWith(
      status: ConversionJobStatus.running,
      startedAt: DateTime.now(),
      cancellationToken: token,
    );
    
    _activeJobs[job.id] = runningJob;
    _notifyJobUpdate(runningJob);
    
    try {
      final converter = _converters[job.format]!;
      
      final outputPath = await converter.convert(
        inputPath: job.inputPath,
        outputDir: job.outputDir,
        options: job.options,
        onProgress: (progress, message) {
          runningJob = runningJob.copyWith(
            progress: progress,
            statusMessage: message,
          );
          _activeJobs[job.id] = runningJob;
          _notifyJobUpdate(runningJob);
        },
        cancellationToken: token,
      );
      
      final completedJob = runningJob.copyWith(
        status: ConversionJobStatus.completed,
        outputPath: outputPath,
        completedAt: DateTime.now(),
        progress: 1.0,
      );
      
      _activeJobs.remove(job.id);
      _completedJobs[job.id] = completedJob;
      _notifyJobUpdate(completedJob);
      
    } on ConversionCancelledException {
      final cancelledJob = runningJob.copyWith(
        status: ConversionJobStatus.cancelled,
        completedAt: DateTime.now(),
      );
      _activeJobs.remove(job.id);
      _notifyJobUpdate(cancelledJob);
      
    } catch (e) {
      final failedJob = runningJob.copyWith(
        status: ConversionJobStatus.failed,
        errorMessage: e.toString(),
        completedAt: DateTime.now(),
      );
      _activeJobs.remove(job.id);
      _notifyJobUpdate(failedJob);
    }
    
    // 次のジョブを処理
    _processQueue();
  }

  void _notifyJobUpdate(ConversionJob job) {
    _jobStreamController.add(job);
  }

  void dispose() {
    _jobStreamController.close();
  }
}

/// 変換ジョブ状態
enum ConversionJobStatus {
  queued('キュー待ち'),
  running('変換中'),
  completed('完了'),
  failed('失敗'),
  cancelled('キャンセル');
  
  final String displayName;
  const ConversionJobStatus(this.displayName);
}

/// 変換ジョブ
@freezed
class ConversionJob with _$ConversionJob {
  const factory ConversionJob({
    required String id,
    required String inputPath,
    required String outputDir,
    required ImportFormat format,
    required ConversionOptions options,
    required ConversionJobStatus status,
    ConversionValidation? validation,
    @Default(0.0) double progress,
    String? statusMessage,
    String? outputPath,
    String? errorMessage,
    DateTime? startedAt,
    DateTime? completedAt,
    CancellationToken? cancellationToken,
  }) = _ConversionJob;
}
```

### 6. 変換進捗UI

```dart
// lib/presentation/widgets/conversion_progress_panel.dart

/// 変換進捗パネル
class ConversionProgressPanel extends ConsumerWidget {
  const ConversionProgressPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final jobs = ref.watch(conversionJobsProvider);
    
    if (jobs.isEmpty) {
      return const SizedBox.shrink();
    }
    
    return Card(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Padding(
            padding: EdgeInsets.all(8),
            child: Text('変換ジョブ', style: TextStyle(fontWeight: FontWeight.bold)),
          ),
          const Divider(height: 1),
          ...jobs.map((job) => _buildJobTile(context, ref, job)),
        ],
      ),
    );
  }

  Widget _buildJobTile(BuildContext context, WidgetRef ref, ConversionJob job) {
    return ListTile(
      leading: _buildStatusIcon(job.status),
      title: Text(path.basename(job.inputPath)),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (job.status == ConversionJobStatus.running) ...[
            LinearProgressIndicator(value: job.progress),
            const SizedBox(height: 4),
            Text(job.statusMessage ?? '処理中...'),
          ] else ...[
            Text(job.status.displayName),
          ],
          if (job.errorMessage != null)
            Text(job.errorMessage!, style: const TextStyle(color: Colors.red)),
        ],
      ),
      trailing: job.status == ConversionJobStatus.running ||
              job.status == ConversionJobStatus.queued
          ? IconButton(
              icon: const Icon(Icons.cancel),
              onPressed: () {
                ref.read(conversionJobManagerProvider).cancelJob(job.id);
              },
            )
          : null,
    );
  }

  Widget _buildStatusIcon(ConversionJobStatus status) {
    switch (status) {
      case ConversionJobStatus.queued:
        return const Icon(Icons.schedule, color: Colors.grey);
      case ConversionJobStatus.running:
        return const SizedBox(
          width: 24,
          height: 24,
          child: CircularProgressIndicator(strokeWidth: 2),
        );
      case ConversionJobStatus.completed:
        return const Icon(Icons.check_circle, color: Colors.green);
      case ConversionJobStatus.failed:
        return const Icon(Icons.error, color: Colors.red);
      case ConversionJobStatus.cancelled:
        return const Icon(Icons.cancel, color: Colors.orange);
    }
  }
}
```

## 技術的な考慮事項

1. **外部ツールの同梱**
   - PDAL、Entwine、obj2gltf等はアプリに同梱またはユーザーにインストールを求める
   - Windows/macOSでバイナリパスが異なる場合の対応

2. **メモリ管理**
   - 大規模点群変換時のメモリ使用量を監視
   - 必要に応じてダウンサンプリングを強制

3. **エラーリカバリ**
   - 変換失敗時の部分出力のクリーンアップ
   - 再試行機能の提供

4. **座標系の統一**
   - 全データをWGS84 (EPSG:4326)に統一
   - ローカル座標系の場合は変換行列を保持

## 成果物・完了条件

- [ ] LAS/LAZファイルが3D Tilesに変換できる
- [ ] OBJ/glTFファイルが3D Tiles (B3DM)に変換できる
- [ ] 変換進捗が表示される
- [ ] 変換のキャンセルが動作する
- [ ] 複数ファイルの並列変換が動作する
- [ ] 変換エラーが適切にハンドリングされる

## 次工程への引き継ぎ事項

- 変換された3D Tilesをレイヤーとして追加する処理は工程07で実装
- 変換設定のプリセット保存は必要に応じて追加
