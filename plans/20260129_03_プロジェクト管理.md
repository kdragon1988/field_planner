# 工程03: プロジェクト管理機能

## 目的・概要

プロジェクトの新規作成、開く、保存、別名保存などの基本的なファイル管理機能を実装する。プロジェクトデータの永続化形式（JSON Schema）を設計し、MRU（最近使ったファイル）履歴機能も提供する。

## 対応する機能要件

- FR-01: プロジェクト新規作成/開く/保存/別名保存
- FR-02: プロジェクトの最近使った履歴（MRU）
- FR-05: プロジェクト単位のメタ情報（作成者/作成日/説明/タグ）
- NFR-31: プロジェクトフォーマットの後方互換（schema version）

## 実装タスク詳細

### 1. プロジェクトフォルダ構造

```
MyProject.agproj/
├── project.json            # メイン設定ファイル
├── placements.json         # 配置物データ（工程09で詳細設計）
├── measurements.json       # 計測データ（工程10で詳細設計）
├── assets_manifest.json    # アセット定義（工程08で詳細設計）
├── layers/                 # 変換済み3D Tilesなど
│   ├── pointcloud_001/
│   └── mesh_001/
├── imports/                # インポート元データ（参照 or コピー）
│   └── original_data.las
├── thumbnails/             # サムネイル画像
│   └── thumbnail.png
└── backups/                # 自動保存バックアップ
    └── project_20260129_120000.json
```

### 2. project.json スキーマ設計

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["schemaVersion", "id", "name", "createdAt", "updatedAt"],
  "properties": {
    "schemaVersion": {
      "type": "string",
      "description": "スキーマバージョン（後方互換用）",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "プロジェクト一意識別子"
    },
    "name": {
      "type": "string",
      "description": "プロジェクト名"
    },
    "description": {
      "type": "string",
      "description": "プロジェクト説明"
    },
    "author": {
      "type": "string",
      "description": "作成者名"
    },
    "tags": {
      "type": "array",
      "items": { "type": "string" },
      "description": "タグ"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time"
    },
    "baseMap": {
      "type": "object",
      "properties": {
        "provider": {
          "type": "string",
          "enum": ["cesium", "google", "osm", "custom"]
        },
        "customUrl": {
          "type": "string",
          "description": "カスタムタイルURL"
        },
        "opacity": {
          "type": "number",
          "minimum": 0,
          "maximum": 1
        }
      }
    },
    "scene": {
      "type": "object",
      "properties": {
        "center": {
          "type": "object",
          "properties": {
            "longitude": { "type": "number" },
            "latitude": { "type": "number" },
            "height": { "type": "number" }
          }
        },
        "camera": {
          "type": "object",
          "properties": {
            "heading": { "type": "number" },
            "pitch": { "type": "number" },
            "roll": { "type": "number" }
          }
        },
        "terrain": {
          "type": "string",
          "enum": ["cesium_world", "none", "custom"]
        }
      }
    },
    "dataLayers": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "name": { "type": "string" },
          "type": { "type": "string", "enum": ["pointcloud", "mesh", "imagery"] },
          "path": { "type": "string" },
          "visible": { "type": "boolean" },
          "opacity": { "type": "number" },
          "order": { "type": "integer" },
          "locked": { "type": "boolean" },
          "sourcePath": { "type": "string" },
          "sourceFormat": { "type": "string" }
        }
      }
    },
    "units": {
      "type": "object",
      "properties": {
        "length": { "type": "string", "enum": ["m", "ft"] },
        "area": { "type": "string", "enum": ["m2", "ft2", "ha", "acre"] }
      }
    },
    "coordinate": {
      "type": "object",
      "properties": {
        "epsg": { "type": "integer" },
        "localOffset": {
          "type": "object",
          "properties": {
            "x": { "type": "number" },
            "y": { "type": "number" },
            "z": { "type": "number" }
          }
        }
      }
    },
    "settings": {
      "type": "object",
      "properties": {
        "gridSize": { "type": "number" },
        "snapEnabled": { "type": "boolean" },
        "snapAngle": { "type": "number" }
      }
    }
  }
}
```

### 3. Dart データモデル実装

```dart
// lib/data/models/project.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:uuid/uuid.dart';

part 'project.freezed.dart';
part 'project.g.dart';

/// プロジェクトデータモデル
/// 
/// プロジェクトの全体設定とメタ情報を保持する
@freezed
class Project with _$Project {
  const factory Project({
    /// スキーマバージョン
    @Default('1.0.0') String schemaVersion,
    
    /// プロジェクトID（UUID）
    required String id,
    
    /// プロジェクト名
    required String name,
    
    /// 説明
    String? description,
    
    /// 作成者
    String? author,
    
    /// タグ
    @Default([]) List<String> tags,
    
    /// 作成日時
    required DateTime createdAt,
    
    /// 更新日時
    required DateTime updatedAt,
    
    /// ベースマップ設定
    BaseMapConfig? baseMap,
    
    /// シーン設定
    SceneConfig? scene,
    
    /// データレイヤー一覧
    @Default([]) List<DataLayer> dataLayers,
    
    /// 単位設定
    @Default(UnitsConfig()) UnitsConfig units,
    
    /// 座標系設定
    CoordinateConfig? coordinate,
    
    /// 編集設定
    @Default(EditorSettings()) EditorSettings settings,
  }) = _Project;

  factory Project.fromJson(Map<String, dynamic> json) => _$ProjectFromJson(json);

  /// 新規プロジェクトを作成
  factory Project.create({
    required String name,
    String? description,
    String? author,
    GeoPosition? center,
  }) {
    final now = DateTime.now();
    return Project(
      id: const Uuid().v4(),
      name: name,
      description: description,
      author: author,
      createdAt: now,
      updatedAt: now,
      scene: SceneConfig(
        center: center ?? const GeoPosition(
          longitude: 139.6917, // 東京
          latitude: 35.6895,
          height: 1000,
        ),
      ),
      baseMap: const BaseMapConfig(provider: 'osm'),
    );
  }
}

/// ベースマップ設定
@freezed
class BaseMapConfig with _$BaseMapConfig {
  const factory BaseMapConfig({
    @Default('osm') String provider,
    String? customUrl,
    @Default(1.0) double opacity,
  }) = _BaseMapConfig;

  factory BaseMapConfig.fromJson(Map<String, dynamic> json) => 
      _$BaseMapConfigFromJson(json);
}

/// シーン設定
@freezed
class SceneConfig with _$SceneConfig {
  const factory SceneConfig({
    GeoPosition? center,
    CameraConfig? camera,
    @Default('cesium_world') String terrain,
  }) = _SceneConfig;

  factory SceneConfig.fromJson(Map<String, dynamic> json) => 
      _$SceneConfigFromJson(json);
}

/// カメラ設定
@freezed
class CameraConfig with _$CameraConfig {
  const factory CameraConfig({
    @Default(0) double heading,
    @Default(-45) double pitch,
    @Default(0) double roll,
  }) = _CameraConfig;

  factory CameraConfig.fromJson(Map<String, dynamic> json) => 
      _$CameraConfigFromJson(json);
}

/// 地理座標
@freezed
class GeoPosition with _$GeoPosition {
  const factory GeoPosition({
    required double longitude,
    required double latitude,
    @Default(0) double height,
  }) = _GeoPosition;

  factory GeoPosition.fromJson(Map<String, dynamic> json) => 
      _$GeoPositionFromJson(json);
}

/// データレイヤー
@freezed
class DataLayer with _$DataLayer {
  const factory DataLayer({
    required String id,
    required String name,
    required String type, // 'pointcloud', 'mesh', 'imagery'
    required String path,
    @Default(true) bool visible,
    @Default(1.0) double opacity,
    @Default(0) int order,
    @Default(false) bool locked,
    String? sourcePath,
    String? sourceFormat,
  }) = _DataLayer;

  factory DataLayer.fromJson(Map<String, dynamic> json) => 
      _$DataLayerFromJson(json);
}

/// 単位設定
@freezed
class UnitsConfig with _$UnitsConfig {
  const factory UnitsConfig({
    @Default('m') String length,
    @Default('m2') String area,
  }) = _UnitsConfig;

  factory UnitsConfig.fromJson(Map<String, dynamic> json) => 
      _$UnitsConfigFromJson(json);
}

/// 座標系設定
@freezed
class CoordinateConfig with _$CoordinateConfig {
  const factory CoordinateConfig({
    @Default(4326) int epsg,
    @Default(Offset3D()) Offset3D localOffset,
  }) = _CoordinateConfig;

  factory CoordinateConfig.fromJson(Map<String, dynamic> json) => 
      _$CoordinateConfigFromJson(json);
}

/// 3Dオフセット
@freezed
class Offset3D with _$Offset3D {
  const factory Offset3D({
    @Default(0) double x,
    @Default(0) double y,
    @Default(0) double z,
  }) = _Offset3D;

  factory Offset3D.fromJson(Map<String, dynamic> json) => 
      _$Offset3DFromJson(json);
}

/// 編集設定
@freezed
class EditorSettings with _$EditorSettings {
  const factory EditorSettings({
    @Default(1.0) double gridSize,
    @Default(true) bool snapEnabled,
    @Default(15) double snapAngle,
  }) = _EditorSettings;

  factory EditorSettings.fromJson(Map<String, dynamic> json) => 
      _$EditorSettingsFromJson(json);
}
```

### 4. プロジェクトリポジトリ実装

```dart
// lib/data/repositories/project_repository.dart

import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as p;

/// プロジェクトリポジトリ
/// 
/// プロジェクトの読み書き、フォルダ構造管理を担当
class ProjectRepository {
  static const String projectFileName = 'project.json';
  static const String projectExtension = '.agproj';

  /// 新規プロジェクトを作成
  /// 
  /// [basePath] 保存先ディレクトリ
  /// [project] プロジェクトデータ
  /// 
  /// Returns: 作成されたプロジェクトフォルダのパス
  Future<String> createProject(String basePath, Project project) async {
    final projectDirName = '${project.name}$projectExtension';
    final projectPath = p.join(basePath, projectDirName);
    
    // プロジェクトフォルダ構造を作成
    await _createProjectStructure(projectPath);
    
    // project.jsonを保存
    await _saveProjectJson(projectPath, project);
    
    // 空のplacements.jsonを作成
    await _createEmptyJson(p.join(projectPath, 'placements.json'), []);
    
    // 空のmeasurements.jsonを作成
    await _createEmptyJson(p.join(projectPath, 'measurements.json'), []);
    
    return projectPath;
  }

  /// プロジェクトを開く
  /// 
  /// [projectPath] プロジェクトフォルダのパス
  /// 
  /// Returns: プロジェクトデータ
  /// Throws: [ProjectLoadException] 読み込みエラー時
  Future<Project> openProject(String projectPath) async {
    final projectFile = File(p.join(projectPath, projectFileName));
    
    if (!await projectFile.exists()) {
      throw ProjectLoadException(
        'project.json が見つかりません: $projectPath',
        projectPath: projectPath,
      );
    }
    
    try {
      final content = await projectFile.readAsString();
      final json = jsonDecode(content) as Map<String, dynamic>;
      
      // スキーマバージョンチェックとマイグレーション
      final project = _migrateIfNeeded(json);
      
      return project;
    } catch (e) {
      throw ProjectLoadException(
        'プロジェクトの読み込みに失敗しました: $e',
        projectPath: projectPath,
        cause: e,
      );
    }
  }

  /// プロジェクトを保存
  Future<void> saveProject(String projectPath, Project project) async {
    final updatedProject = project.copyWith(updatedAt: DateTime.now());
    await _saveProjectJson(projectPath, updatedProject);
  }

  /// プロジェクトを別名で保存
  /// 
  /// [sourcePath] 元のプロジェクトパス
  /// [destPath] 保存先パス
  /// [newName] 新しいプロジェクト名
  Future<String> saveProjectAs(
    String sourcePath,
    String destPath,
    String newName,
  ) async {
    final newProjectPath = p.join(destPath, '$newName$projectExtension');
    
    // フォルダをコピー
    await _copyDirectory(Directory(sourcePath), Directory(newProjectPath));
    
    // プロジェクト情報を更新
    final project = await openProject(newProjectPath);
    final renamedProject = project.copyWith(
      name: newName,
      updatedAt: DateTime.now(),
    );
    await saveProject(newProjectPath, renamedProject);
    
    return newProjectPath;
  }

  /// プロジェクトの整合性をチェック
  Future<ProjectValidationResult> validateProject(String projectPath) async {
    final errors = <String>[];
    final warnings = <String>[];
    
    // project.json存在チェック
    if (!await File(p.join(projectPath, projectFileName)).exists()) {
      errors.add('project.json が見つかりません');
    }
    
    // 必須フォルダチェック
    final requiredDirs = ['layers', 'imports', 'thumbnails'];
    for (final dir in requiredDirs) {
      if (!await Directory(p.join(projectPath, dir)).exists()) {
        warnings.add('$dir フォルダが見つかりません');
      }
    }
    
    // データレイヤー参照チェック
    try {
      final project = await openProject(projectPath);
      for (final layer in project.dataLayers) {
        final layerPath = p.join(projectPath, layer.path);
        if (!await Directory(layerPath).exists() && 
            !await File(layerPath).exists()) {
          errors.add('レイヤー "${layer.name}" のデータが見つかりません: ${layer.path}');
        }
      }
    } catch (e) {
      errors.add('プロジェクト設定の読み込みに失敗: $e');
    }
    
    return ProjectValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
    );
  }

  // プライベートメソッド

  Future<void> _createProjectStructure(String projectPath) async {
    await Directory(projectPath).create(recursive: true);
    await Directory(p.join(projectPath, 'layers')).create();
    await Directory(p.join(projectPath, 'imports')).create();
    await Directory(p.join(projectPath, 'thumbnails')).create();
    await Directory(p.join(projectPath, 'backups')).create();
  }

  Future<void> _saveProjectJson(String projectPath, Project project) async {
    final file = File(p.join(projectPath, projectFileName));
    final json = jsonEncode(project.toJson());
    await file.writeAsString(json, flush: true);
  }

  Future<void> _createEmptyJson(String path, dynamic initialData) async {
    final file = File(path);
    await file.writeAsString(jsonEncode(initialData));
  }

  Project _migrateIfNeeded(Map<String, dynamic> json) {
    final version = json['schemaVersion'] as String? ?? '1.0.0';
    
    // バージョンに応じたマイグレーション処理
    // 現在は1.0.0のみなのでそのまま返す
    return Project.fromJson(json);
  }

  Future<void> _copyDirectory(Directory source, Directory destination) async {
    await destination.create(recursive: true);
    
    await for (final entity in source.list(recursive: false)) {
      final newPath = p.join(
        destination.path,
        p.basename(entity.path),
      );
      
      if (entity is Directory) {
        await _copyDirectory(entity, Directory(newPath));
      } else if (entity is File) {
        await entity.copy(newPath);
      }
    }
  }
}

/// プロジェクト読み込み例外
class ProjectLoadException implements Exception {
  final String message;
  final String projectPath;
  final Object? cause;

  ProjectLoadException(
    this.message, {
    required this.projectPath,
    this.cause,
  });

  @override
  String toString() => 'ProjectLoadException: $message (path: $projectPath)';
}

/// プロジェクト検証結果
class ProjectValidationResult {
  final bool isValid;
  final List<String> errors;
  final List<String> warnings;

  ProjectValidationResult({
    required this.isValid,
    required this.errors,
    required this.warnings,
  });
}
```

### 5. MRU（最近使ったファイル）管理

```dart
// lib/data/services/recent_projects_service.dart

import 'package:hive/hive.dart';

/// 最近使ったプロジェクト管理サービス
class RecentProjectsService {
  static const String _boxName = 'recent_projects';
  static const int maxRecentProjects = 10;
  
  late Box<RecentProjectEntry> _box;

  /// 初期化
  Future<void> initialize() async {
    Hive.registerAdapter(RecentProjectEntryAdapter());
    _box = await Hive.openBox<RecentProjectEntry>(_boxName);
  }

  /// 最近使ったプロジェクト一覧を取得
  List<RecentProjectEntry> getRecentProjects() {
    final entries = _box.values.toList();
    entries.sort((a, b) => b.lastOpenedAt.compareTo(a.lastOpenedAt));
    return entries;
  }

  /// プロジェクトを履歴に追加
  Future<void> addRecentProject({
    required String path,
    required String name,
    String? thumbnailPath,
  }) async {
    // 既存エントリを削除（重複防止）
    final existingKey = _box.keys.cast<String>().firstWhere(
      (key) => _box.get(key)?.path == path,
      orElse: () => '',
    );
    if (existingKey.isNotEmpty) {
      await _box.delete(existingKey);
    }
    
    // 新規エントリを追加
    final entry = RecentProjectEntry(
      path: path,
      name: name,
      lastOpenedAt: DateTime.now(),
      thumbnailPath: thumbnailPath,
    );
    await _box.put(path, entry);
    
    // 最大数を超えたら古いものを削除
    await _trimOldEntries();
  }

  /// 履歴からプロジェクトを削除
  Future<void> removeRecentProject(String path) async {
    await _box.delete(path);
  }

  /// 履歴をクリア
  Future<void> clearHistory() async {
    await _box.clear();
  }

  /// 存在しないプロジェクトを履歴から削除
  Future<void> cleanupInvalidEntries() async {
    final invalidKeys = <String>[];
    
    for (final key in _box.keys.cast<String>()) {
      final entry = _box.get(key);
      if (entry != null && !await Directory(entry.path).exists()) {
        invalidKeys.add(key);
      }
    }
    
    for (final key in invalidKeys) {
      await _box.delete(key);
    }
  }

  Future<void> _trimOldEntries() async {
    final entries = getRecentProjects();
    if (entries.length > maxRecentProjects) {
      final toRemove = entries.skip(maxRecentProjects);
      for (final entry in toRemove) {
        await _box.delete(entry.path);
      }
    }
  }
}

/// 最近使ったプロジェクトエントリ
@HiveType(typeId: 0)
class RecentProjectEntry extends HiveObject {
  @HiveField(0)
  final String path;

  @HiveField(1)
  final String name;

  @HiveField(2)
  final DateTime lastOpenedAt;

  @HiveField(3)
  final String? thumbnailPath;

  RecentProjectEntry({
    required this.path,
    required this.name,
    required this.lastOpenedAt,
    this.thumbnailPath,
  });
}
```

### 6. プロジェクト管理Provider（状態管理）

```dart
// lib/presentation/providers/project_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 現在のプロジェクト状態
final currentProjectProvider = StateNotifierProvider<ProjectNotifier, ProjectState>((ref) {
  return ProjectNotifier(ref.read(projectRepositoryProvider));
});

/// プロジェクト状態
class ProjectState {
  final Project? project;
  final String? projectPath;
  final bool isDirty; // 未保存の変更あり
  final bool isLoading;
  final String? errorMessage;

  const ProjectState({
    this.project,
    this.projectPath,
    this.isDirty = false,
    this.isLoading = false,
    this.errorMessage,
  });

  ProjectState copyWith({
    Project? project,
    String? projectPath,
    bool? isDirty,
    bool? isLoading,
    String? errorMessage,
  }) {
    return ProjectState(
      project: project ?? this.project,
      projectPath: projectPath ?? this.projectPath,
      isDirty: isDirty ?? this.isDirty,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
    );
  }
}

/// プロジェクト状態管理
class ProjectNotifier extends StateNotifier<ProjectState> {
  final ProjectRepository _repository;

  ProjectNotifier(this._repository) : super(const ProjectState());

  /// 新規プロジェクト作成
  Future<void> createProject({
    required String basePath,
    required String name,
    String? description,
    GeoPosition? center,
  }) async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      final project = Project.create(
        name: name,
        description: description,
        center: center,
      );
      
      final projectPath = await _repository.createProject(basePath, project);
      
      state = ProjectState(
        project: project,
        projectPath: projectPath,
        isDirty: false,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: 'プロジェクト作成に失敗しました: $e',
      );
    }
  }

  /// プロジェクトを開く
  Future<void> openProject(String projectPath) async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      final project = await _repository.openProject(projectPath);
      
      state = ProjectState(
        project: project,
        projectPath: projectPath,
        isDirty: false,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: 'プロジェクトを開けませんでした: $e',
      );
    }
  }

  /// プロジェクトを保存
  Future<void> saveProject() async {
    if (state.project == null || state.projectPath == null) return;
    
    state = state.copyWith(isLoading: true);
    
    try {
      await _repository.saveProject(state.projectPath!, state.project!);
      state = state.copyWith(isDirty: false, isLoading: false);
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: '保存に失敗しました: $e',
      );
    }
  }

  /// プロジェクトを更新（未保存状態にする）
  void updateProject(Project project) {
    state = state.copyWith(project: project, isDirty: true);
  }

  /// プロジェクトを閉じる
  Future<bool> closeProject() async {
    if (state.isDirty) {
      // 呼び出し元で保存確認ダイアログを表示
      return false;
    }
    state = const ProjectState();
    return true;
  }
}
```

## 技術的な考慮事項

1. **データ整合性**
   - 保存時はまず一時ファイルに書き込み、成功後にリネーム
   - JSONパースエラー時の詳細なエラーメッセージ

2. **後方互換性**
   - `schemaVersion` フィールドによるバージョン管理
   - マイグレーション関数で古い形式を新形式に変換

3. **パフォーマンス**
   - 大きなプロジェクトでも高速に開けるよう、遅延読み込みを活用
   - 配置物・計測データは別ファイルで管理

4. **エラーハンドリング**
   - ファイル読み書きエラーの適切な例外処理
   - ユーザーへの分かりやすいエラーメッセージ

## 成果物・完了条件

- [ ] Project データモデルが定義され、JSON変換が動作する
- [ ] 新規プロジェクト作成でフォルダ構造が正しく生成される
- [ ] プロジェクトの開く/保存/別名保存が動作する
- [ ] MRU履歴が正しく記録・表示される
- [ ] プロジェクト整合性チェックが動作する
- [ ] スキーマバージョン管理の仕組みが実装されている

## 次工程への引き継ぎ事項

- `Project.baseMap` 設定は工程04で利用
- `Project.dataLayers` は工程05-07で拡張
- 自動保存機能は工程12で実装
