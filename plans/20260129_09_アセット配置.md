# 工程09: アセット配置機能

## 目的・概要

Minecraft風の直感的なアセット配置操作を実装する。クリック配置、ドラッグ移動、回転・スケール・高さ調整、スナップ機能（地面/グリッド/オブジェクト）、複製・整列・グループ化機能を提供する。

## 対応する機能要件

- FR-32: 配置操作（クリック配置、ドラッグ移動、回転、スケール、高さ調整）
- FR-33: スナップ（地面スナップ、グリッドスナップ、既存オブジェクトへのスナップ）
- FR-34: 複製（Ctrl+D）、整列、グループ化、ロック
- FR-35: プロパティ（名称、寸法、材質/色、タグ）
- FR-36: 衝突判定の簡易チェック（オプション）

## 実装タスク詳細

### 1. 配置物データモデル

```dart
// lib/data/models/placement.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'placement.freezed.dart';
part 'placement.g.dart';

/// 配置物
@freezed
class Placement with _$Placement {
  const factory Placement({
    /// 一意識別子
    required String id,
    
    /// アセットID
    required String assetId,
    
    /// 表示名
    required String name,
    
    /// 位置（地理座標）
    required GeoPosition position,
    
    /// 回転（度）
    @Default(PlacementRotation()) PlacementRotation rotation,
    
    /// スケール
    @Default(PlacementScale()) PlacementScale scale,
    
    /// 表示フラグ
    @Default(true) bool visible,
    
    /// ロック状態
    @Default(false) bool locked,
    
    /// グループID
    String? groupId,
    
    /// タグ
    @Default([]) List<String> tags,
    
    /// カスタムプロパティ
    Map<String, dynamic>? properties,
    
    /// 作成日時
    required DateTime createdAt,
    
    /// 更新日時
    required DateTime updatedAt,
  }) = _Placement;

  factory Placement.fromJson(Map<String, dynamic> json) => 
      _$PlacementFromJson(json);
  
  /// 新規配置物を作成
  factory Placement.create({
    required String assetId,
    required String name,
    required GeoPosition position,
  }) {
    final now = DateTime.now();
    return Placement(
      id: const Uuid().v4(),
      assetId: assetId,
      name: name,
      position: position,
      createdAt: now,
      updatedAt: now,
    );
  }
}

/// 回転
@freezed
class PlacementRotation with _$PlacementRotation {
  const factory PlacementRotation({
    /// X軸回転（ピッチ、度）
    @Default(0) double pitch,
    
    /// Y軸回転（ロール、度）
    @Default(0) double roll,
    
    /// Z軸回転（ヘディング、度）
    @Default(0) double heading,
  }) = _PlacementRotation;

  factory PlacementRotation.fromJson(Map<String, dynamic> json) => 
      _$PlacementRotationFromJson(json);
}

/// スケール
@freezed
class PlacementScale with _$PlacementScale {
  const factory PlacementScale({
    @Default(1.0) double x,
    @Default(1.0) double y,
    @Default(1.0) double z,
  }) = _PlacementScale;

  factory PlacementScale.fromJson(Map<String, dynamic> json) => 
      _$PlacementScaleFromJson(json);
  
  /// 均一スケール
  factory PlacementScale.uniform(double scale) => PlacementScale(
    x: scale,
    y: scale,
    z: scale,
  );
  
  bool get isUniform => x == y && y == z;
}

/// グループ
@freezed
class PlacementGroup with _$PlacementGroup {
  const factory PlacementGroup({
    required String id,
    required String name,
    @Default([]) List<String> memberIds,
    @Default(false) bool locked,
  }) = _PlacementGroup;

  factory PlacementGroup.fromJson(Map<String, dynamic> json) => 
      _$PlacementGroupFromJson(json);
}
```

### 2. 配置物リポジトリ

```dart
// lib/data/repositories/placement_repository.dart

import 'dart:convert';
import 'dart:io';

/// 配置物リポジトリ
class PlacementRepository {
  static const String _fileName = 'placements.json';
  
  /// 配置物一覧を読み込み
  Future<List<Placement>> loadPlacements(String projectPath) async {
    final file = File(path.join(projectPath, _fileName));
    
    if (!await file.exists()) {
      return [];
    }
    
    try {
      final content = await file.readAsString();
      final json = jsonDecode(content);
      
      if (json is List) {
        return json
            .map((e) => Placement.fromJson(e as Map<String, dynamic>))
            .toList();
      }
      
      // 新形式（グループ情報含む）
      final data = json as Map<String, dynamic>;
      final placementsJson = data['placements'] as List<dynamic>;
      return placementsJson
          .map((e) => Placement.fromJson(e as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint('Failed to load placements: $e');
      return [];
    }
  }

  /// 配置物一覧を保存
  Future<void> savePlacements(
    String projectPath,
    List<Placement> placements,
    List<PlacementGroup> groups,
  ) async {
    final file = File(path.join(projectPath, _fileName));
    
    final data = {
      'version': '1.0.0',
      'placements': placements.map((p) => p.toJson()).toList(),
      'groups': groups.map((g) => g.toJson()).toList(),
    };
    
    await file.writeAsString(jsonEncode(data), flush: true);
  }

  /// 単一配置物を追加
  Future<void> addPlacement(String projectPath, Placement placement) async {
    final placements = await loadPlacements(projectPath);
    placements.add(placement);
    await savePlacements(projectPath, placements, []);
  }

  /// 配置物を更新
  Future<void> updatePlacement(String projectPath, Placement placement) async {
    final placements = await loadPlacements(projectPath);
    final index = placements.indexWhere((p) => p.id == placement.id);
    if (index != -1) {
      placements[index] = placement.copyWith(updatedAt: DateTime.now());
      await savePlacements(projectPath, placements, []);
    }
  }

  /// 配置物を削除
  Future<void> removePlacement(String projectPath, String placementId) async {
    final placements = await loadPlacements(projectPath);
    placements.removeWhere((p) => p.id == placementId);
    await savePlacements(projectPath, placements, []);
  }
}
```

### 3. cesium_bridge.js 配置機能拡張

```javascript
// assets/cesium/cesium_bridge.js に追加

/**
 * 配置物管理
 */
const placementEntities = new Map();
let placementMode = null; // 'place', 'move', 'rotate', 'scale'
let previewEntity = null;
let selectedPlacement = null;

// スナップ設定
const snapSettings = {
  gridEnabled: true,
  gridSize: 1.0, // メートル
  groundEnabled: true,
  angleEnabled: true,
  angleStep: 15, // 度
};

/**
 * 配置物を追加
 * @param {Object} placement - 配置物データ
 * @param {string} modelUrl - モデルURL
 */
function addPlacement(placement, modelUrl) {
  const position = Cesium.Cartesian3.fromDegrees(
    placement.position.longitude,
    placement.position.latitude,
    placement.position.height
  );
  
  const heading = Cesium.Math.toRadians(placement.rotation.heading);
  const pitch = Cesium.Math.toRadians(placement.rotation.pitch);
  const roll = Cesium.Math.toRadians(placement.rotation.roll);
  const orientation = Cesium.Transforms.headingPitchRollQuaternion(
    position,
    new Cesium.HeadingPitchRoll(heading, pitch, roll)
  );

  const entity = viewer.entities.add({
    id: placement.id,
    name: placement.name,
    position: position,
    orientation: orientation,
    model: {
      uri: modelUrl,
      scale: placement.scale.x, // 均一スケールを仮定
      minimumPixelSize: 64,
      maximumScale: 20000,
    },
    show: placement.visible,
  });

  placementEntities.set(placement.id, {
    entity: entity,
    placement: placement,
    modelUrl: modelUrl,
  });

  sendToFlutter('placementAdded', { id: placement.id });
}

/**
 * 配置物を削除
 * @param {string} placementId - 配置物ID
 */
function removePlacement(placementId) {
  const data = placementEntities.get(placementId);
  if (data) {
    viewer.entities.remove(data.entity);
    placementEntities.delete(placementId);
  }
}

/**
 * 配置物を更新
 * @param {Object} placement - 配置物データ
 */
function updatePlacement(placement) {
  const data = placementEntities.get(placement.id);
  if (!data) return;
  
  const position = Cesium.Cartesian3.fromDegrees(
    placement.position.longitude,
    placement.position.latitude,
    placement.position.height
  );
  
  const heading = Cesium.Math.toRadians(placement.rotation.heading);
  const pitch = Cesium.Math.toRadians(placement.rotation.pitch);
  const roll = Cesium.Math.toRadians(placement.rotation.roll);
  const orientation = Cesium.Transforms.headingPitchRollQuaternion(
    position,
    new Cesium.HeadingPitchRoll(heading, pitch, roll)
  );

  data.entity.position = position;
  data.entity.orientation = orientation;
  data.entity.model.scale = placement.scale.x;
  data.entity.show = placement.visible;
  data.placement = placement;
}

/**
 * 配置モードを開始
 * @param {string} assetId - アセットID
 * @param {string} modelUrl - モデルURL
 */
function startPlacementMode(assetId, modelUrl) {
  // 既存のプレビューを削除
  if (previewEntity) {
    viewer.entities.remove(previewEntity);
  }
  
  placementMode = 'place';
  
  // プレビューエンティティを作成
  previewEntity = viewer.entities.add({
    id: 'preview_' + assetId,
    position: Cesium.Cartesian3.ZERO,
    model: {
      uri: modelUrl,
      scale: 1.0,
      color: Cesium.Color.WHITE.withAlpha(0.7),
      silhouetteColor: Cesium.Color.LIME,
      silhouetteSize: 2,
    },
    show: false,
  });
  
  // マウス移動イベントを設定
  viewer.screenSpaceEventHandler.setInputAction((movement) => {
    if (placementMode !== 'place') return;
    
    const position = getGroundPosition(movement.endPosition);
    if (position) {
      const snappedPosition = applyGridSnap(position);
      previewEntity.position = snappedPosition;
      previewEntity.show = true;
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  
  // クリックイベントで配置確定
  viewer.screenSpaceEventHandler.setInputAction((click) => {
    if (placementMode !== 'place') return;
    
    const position = getGroundPosition(click.position);
    if (position) {
      const snappedPosition = applyGridSnap(position);
      const cartographic = Cesium.Cartographic.fromCartesian(snappedPosition);
      
      sendToFlutter('placementConfirmed', {
        assetId: assetId,
        position: {
          longitude: Cesium.Math.toDegrees(cartographic.longitude),
          latitude: Cesium.Math.toDegrees(cartographic.latitude),
          height: cartographic.height,
        }
      });
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
  
  // 右クリックでキャンセル
  viewer.screenSpaceEventHandler.setInputAction(() => {
    cancelPlacementMode();
    sendToFlutter('placementCancelled', {});
  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
}

/**
 * 配置モードをキャンセル
 */
function cancelPlacementMode() {
  if (previewEntity) {
    viewer.entities.remove(previewEntity);
    previewEntity = null;
  }
  placementMode = null;
  
  // イベントハンドラをリセット
  viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
}

/**
 * 地面上の位置を取得
 * @param {Cesium.Cartesian2} screenPosition - スクリーン座標
 * @returns {Cesium.Cartesian3|null} - 地面上の位置
 */
function getGroundPosition(screenPosition) {
  // 地形がある場合は地形上の位置を取得
  const ray = viewer.camera.getPickRay(screenPosition);
  const position = viewer.scene.globe.pick(ray, viewer.scene);
  
  if (position) {
    if (snapSettings.groundEnabled) {
      // 地形の高さを取得
      const cartographic = Cesium.Cartographic.fromCartesian(position);
      const terrainHeight = viewer.scene.globe.getHeight(cartographic);
      if (terrainHeight !== undefined) {
        cartographic.height = terrainHeight;
        return Cesium.Cartesian3.fromRadians(
          cartographic.longitude,
          cartographic.latitude,
          cartographic.height
        );
      }
    }
    return position;
  }
  
  return null;
}

/**
 * グリッドスナップを適用
 * @param {Cesium.Cartesian3} position - 元の位置
 * @returns {Cesium.Cartesian3} - スナップ後の位置
 */
function applyGridSnap(position) {
  if (!snapSettings.gridEnabled) return position;
  
  const cartographic = Cesium.Cartographic.fromCartesian(position);
  
  // メートル単位でスナップ
  // 経度1度 ≈ 111km * cos(緯度) なので、メートルを度に変換
  const latRad = cartographic.latitude;
  const metersPerDegreeLon = 111320 * Math.cos(latRad);
  const metersPerDegreeLat = 110540;
  
  const gridSize = snapSettings.gridSize;
  const lonStep = gridSize / metersPerDegreeLon;
  const latStep = gridSize / metersPerDegreeLat;
  
  const snappedLon = Math.round(cartographic.longitude / lonStep) * lonStep;
  const snappedLat = Math.round(cartographic.latitude / latStep) * latStep;
  
  return Cesium.Cartesian3.fromRadians(
    snappedLon,
    snappedLat,
    cartographic.height
  );
}

/**
 * 角度スナップを適用
 * @param {number} angle - 元の角度（度）
 * @returns {number} - スナップ後の角度
 */
function applyAngleSnap(angle) {
  if (!snapSettings.angleEnabled) return angle;
  const step = snapSettings.angleStep;
  return Math.round(angle / step) * step;
}

/**
 * 配置物を選択
 * @param {string} placementId - 配置物ID
 */
function selectPlacement(placementId) {
  // 既存の選択を解除
  if (selectedPlacement) {
    const prevData = placementEntities.get(selectedPlacement);
    if (prevData) {
      prevData.entity.model.silhouetteColor = Cesium.Color.TRANSPARENT;
      prevData.entity.model.silhouetteSize = 0;
    }
  }
  
  selectedPlacement = placementId;
  
  // 新しい選択をハイライト
  const data = placementEntities.get(placementId);
  if (data) {
    data.entity.model.silhouetteColor = Cesium.Color.YELLOW;
    data.entity.model.silhouetteSize = 3;
  }
  
  sendToFlutter('placementSelected', { id: placementId });
}

/**
 * 選択を解除
 */
function deselectPlacement() {
  if (selectedPlacement) {
    const data = placementEntities.get(selectedPlacement);
    if (data) {
      data.entity.model.silhouetteColor = Cesium.Color.TRANSPARENT;
      data.entity.model.silhouetteSize = 0;
    }
    selectedPlacement = null;
  }
  
  sendToFlutter('placementDeselected', {});
}

/**
 * スナップ設定を更新
 * @param {Object} settings - 設定
 */
function updateSnapSettings(settings) {
  Object.assign(snapSettings, settings);
}

/**
 * 配置物にズーム
 * @param {string} placementId - 配置物ID
 */
function zoomToPlacement(placementId) {
  const data = placementEntities.get(placementId);
  if (data) {
    viewer.flyTo(data.entity, {
      duration: 1.5,
      offset: new Cesium.HeadingPitchRange(0, -0.5, 50)
    });
  }
}

// handleFlutterMessage に追加
function handleFlutterMessage(method, params) {
  switch (method) {
    // ... 既存のcase
    
    case 'addPlacement':
      addPlacement(params.placement, params.modelUrl);
      break;
    case 'removePlacement':
      removePlacement(params.placementId);
      break;
    case 'updatePlacement':
      updatePlacement(params.placement);
      break;
    case 'startPlacementMode':
      startPlacementMode(params.assetId, params.modelUrl);
      break;
    case 'cancelPlacementMode':
      cancelPlacementMode();
      break;
    case 'selectPlacement':
      selectPlacement(params.placementId);
      break;
    case 'deselectPlacement':
      deselectPlacement();
      break;
    case 'updateSnapSettings':
      updateSnapSettings(params);
      break;
    case 'zoomToPlacement':
      zoomToPlacement(params.placementId);
      break;
  }
}
```

### 4. Flutter側 PlacementController

```dart
// lib/infrastructure/webview/placement_controller.dart

/// 配置物管理コントローラ
class PlacementController extends ChangeNotifier {
  final CesiumController _cesiumController;
  final PlacementRepository _repository;
  final AssetRepository _assetRepository;
  
  final List<Placement> _placements = [];
  final List<PlacementGroup> _groups = [];
  
  String? _selectedPlacementId;
  String? _currentAssetIdForPlacement;
  
  List<Placement> get placements => List.unmodifiable(_placements);
  List<PlacementGroup> get groups => List.unmodifiable(_groups);
  Placement? get selectedPlacement => _placements.firstWhereOrNull(
    (p) => p.id == _selectedPlacementId,
  );

  PlacementController(
    this._cesiumController,
    this._repository,
    this._assetRepository,
  ) {
    _cesiumController.onPlacementConfirmed = _onPlacementConfirmed;
    _cesiumController.onPlacementSelected = _onPlacementSelected;
    _cesiumController.onPlacementDeselected = _onPlacementDeselected;
  }

  /// プロジェクトの配置物を読み込み
  Future<void> loadPlacements(String projectPath) async {
    _placements.clear();
    _placements.addAll(await _repository.loadPlacements(projectPath));
    
    // CesiumJSに配置物を追加
    for (final placement in _placements) {
      await _addPlacementToCesium(placement);
    }
    
    notifyListeners();
  }

  /// 配置モードを開始
  Future<void> startPlacementMode(String assetId) async {
    _currentAssetIdForPlacement = assetId;
    
    final assets = await _assetRepository.getAllAssets();
    final asset = assets.firstWhere((a) => a.id == assetId);
    final modelUrl = _assetRepository.getModelFullPath(asset);
    
    await _cesiumController.executeMethod('startPlacementMode', {
      'assetId': assetId,
      'modelUrl': modelUrl,
    });
  }

  /// 配置モードをキャンセル
  Future<void> cancelPlacementMode() async {
    _currentAssetIdForPlacement = null;
    await _cesiumController.executeMethod('cancelPlacementMode', {});
  }

  /// 配置物を選択
  Future<void> selectPlacement(String placementId) async {
    await _cesiumController.executeMethod('selectPlacement', {
      'placementId': placementId,
    });
  }

  /// 選択を解除
  Future<void> deselectPlacement() async {
    await _cesiumController.executeMethod('deselectPlacement', {});
  }

  /// 配置物を削除
  Future<void> deletePlacement(String placementId, String projectPath) async {
    await _cesiumController.executeMethod('removePlacement', {
      'placementId': placementId,
    });
    
    _placements.removeWhere((p) => p.id == placementId);
    await _repository.savePlacements(projectPath, _placements, _groups);
    
    if (_selectedPlacementId == placementId) {
      _selectedPlacementId = null;
    }
    
    notifyListeners();
  }

  /// 配置物を複製
  Future<void> duplicatePlacement(
    String placementId,
    String projectPath, {
    double offsetX = 2.0,
    double offsetY = 0.0,
  }) async {
    final original = _placements.firstWhere((p) => p.id == placementId);
    
    final duplicate = Placement.create(
      assetId: original.assetId,
      name: '${original.name} (コピー)',
      position: GeoPosition(
        longitude: original.position.longitude + offsetX / 111320,
        latitude: original.position.latitude + offsetY / 110540,
        height: original.position.height,
      ),
    ).copyWith(
      rotation: original.rotation,
      scale: original.scale,
      tags: original.tags,
    );
    
    _placements.add(duplicate);
    await _addPlacementToCesium(duplicate);
    await _repository.savePlacements(projectPath, _placements, _groups);
    
    notifyListeners();
  }

  /// 配置物を更新
  Future<void> updatePlacement(
    Placement placement,
    String projectPath,
  ) async {
    final index = _placements.indexWhere((p) => p.id == placement.id);
    if (index == -1) return;
    
    final updated = placement.copyWith(updatedAt: DateTime.now());
    _placements[index] = updated;
    
    await _cesiumController.executeMethod('updatePlacement', {
      'placement': updated.toJson(),
    });
    
    await _repository.savePlacements(projectPath, _placements, _groups);
    notifyListeners();
  }

  /// スナップ設定を更新
  Future<void> updateSnapSettings({
    bool? gridEnabled,
    double? gridSize,
    bool? groundEnabled,
    bool? angleEnabled,
    double? angleStep,
  }) async {
    await _cesiumController.executeMethod('updateSnapSettings', {
      if (gridEnabled != null) 'gridEnabled': gridEnabled,
      if (gridSize != null) 'gridSize': gridSize,
      if (groundEnabled != null) 'groundEnabled': groundEnabled,
      if (angleEnabled != null) 'angleEnabled': angleEnabled,
      if (angleStep != null) 'angleStep': angleStep,
    });
  }

  /// 配置物にズーム
  Future<void> zoomToPlacement(String placementId) async {
    await _cesiumController.executeMethod('zoomToPlacement', {
      'placementId': placementId,
    });
  }

  // プライベートメソッド

  Future<void> _addPlacementToCesium(Placement placement) async {
    final assets = await _assetRepository.getAllAssets();
    final asset = assets.firstWhereOrNull((a) => a.id == placement.assetId);
    if (asset == null) return;
    
    final modelUrl = _assetRepository.getModelFullPath(asset);
    
    await _cesiumController.executeMethod('addPlacement', {
      'placement': placement.toJson(),
      'modelUrl': modelUrl,
    });
  }

  void _onPlacementConfirmed(Map<String, dynamic> data) async {
    if (_currentAssetIdForPlacement == null) return;
    
    final assets = await _assetRepository.getAllAssets();
    final asset = assets.firstWhere((a) => a.id == _currentAssetIdForPlacement);
    
    final placement = Placement.create(
      assetId: _currentAssetIdForPlacement!,
      name: asset.name,
      position: GeoPosition.fromJson(data['position'] as Map<String, dynamic>),
    );
    
    _placements.add(placement);
    await _addPlacementToCesium(placement);
    
    // 使用回数をインクリメント
    await _assetRepository.incrementUsage(_currentAssetIdForPlacement!);
    
    notifyListeners();
    
    // 通知
    _cesiumController.notifyPlacementAdded(placement.id);
  }

  void _onPlacementSelected(Map<String, dynamic> data) {
    _selectedPlacementId = data['id'] as String;
    notifyListeners();
  }

  void _onPlacementDeselected(Map<String, dynamic> data) {
    _selectedPlacementId = null;
    notifyListeners();
  }
}
```

### 5. プロパティインスペクタUI

```dart
// lib/presentation/widgets/placement_inspector.dart

/// 配置物プロパティインスペクタ
class PlacementInspector extends ConsumerWidget {
  const PlacementInspector({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final placement = ref.watch(selectedPlacementProvider);
    
    if (placement == null) {
      return const Center(
        child: Text('配置物を選択してください'),
      );
    }
    
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ヘッダ
          _buildHeader(context, ref, placement),
          const Divider(),
          
          // 位置
          _buildSection('位置', [
            _buildPositionFields(ref, placement),
          ]),
          
          // 回転
          _buildSection('回転', [
            _buildRotationFields(ref, placement),
          ]),
          
          // スケール
          _buildSection('スケール', [
            _buildScaleFields(ref, placement),
          ]),
          
          // プロパティ
          _buildSection('プロパティ', [
            _buildPropertyFields(ref, placement),
          ]),
          
          // アクション
          const SizedBox(height: 16),
          _buildActions(context, ref, placement),
        ],
      ),
    );
  }

  Widget _buildHeader(BuildContext context, WidgetRef ref, Placement placement) {
    return Row(
      children: [
        Expanded(
          child: TextField(
            controller: TextEditingController(text: placement.name),
            decoration: const InputDecoration(
              labelText: '名前',
              border: OutlineInputBorder(),
            ),
            onSubmitted: (value) {
              ref.read(placementControllerProvider).updatePlacement(
                placement.copyWith(name: value),
                ref.read(currentProjectPathProvider)!,
              );
            },
          ),
        ),
        const SizedBox(width: 8),
        IconButton(
          icon: Icon(
            placement.locked ? Icons.lock : Icons.lock_open,
            color: placement.locked ? Colors.red : null,
          ),
          onPressed: () {
            ref.read(placementControllerProvider).updatePlacement(
              placement.copyWith(locked: !placement.locked),
              ref.read(currentProjectPathProvider)!,
            );
          },
          tooltip: placement.locked ? 'ロック解除' : 'ロック',
        ),
      ],
    );
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        ...children,
        const SizedBox(height: 16),
      ],
    );
  }

  Widget _buildPositionFields(WidgetRef ref, Placement placement) {
    return Column(
      children: [
        _buildNumberField(
          label: '経度',
          value: placement.position.longitude,
          suffix: '°',
          onChanged: (v) => _updatePosition(ref, placement, longitude: v),
        ),
        _buildNumberField(
          label: '緯度',
          value: placement.position.latitude,
          suffix: '°',
          onChanged: (v) => _updatePosition(ref, placement, latitude: v),
        ),
        _buildNumberField(
          label: '高さ',
          value: placement.position.height,
          suffix: 'm',
          onChanged: (v) => _updatePosition(ref, placement, height: v),
        ),
      ],
    );
  }

  Widget _buildRotationFields(WidgetRef ref, Placement placement) {
    return Column(
      children: [
        _buildSliderField(
          label: '方位角',
          value: placement.rotation.heading,
          min: 0,
          max: 360,
          suffix: '°',
          onChanged: (v) => _updateRotation(ref, placement, heading: v),
        ),
        _buildSliderField(
          label: 'ピッチ',
          value: placement.rotation.pitch,
          min: -90,
          max: 90,
          suffix: '°',
          onChanged: (v) => _updateRotation(ref, placement, pitch: v),
        ),
        _buildSliderField(
          label: 'ロール',
          value: placement.rotation.roll,
          min: -180,
          max: 180,
          suffix: '°',
          onChanged: (v) => _updateRotation(ref, placement, roll: v),
        ),
      ],
    );
  }

  Widget _buildScaleFields(WidgetRef ref, Placement placement) {
    final isUniform = placement.scale.isUniform;
    
    return Column(
      children: [
        Row(
          children: [
            const Text('均一スケール'),
            const Spacer(),
            Switch(
              value: isUniform,
              onChanged: (v) {
                if (v) {
                  _updateScale(ref, placement, 
                    x: placement.scale.x,
                    y: placement.scale.x,
                    z: placement.scale.x,
                  );
                }
              },
            ),
          ],
        ),
        if (isUniform)
          _buildSliderField(
            label: 'スケール',
            value: placement.scale.x,
            min: 0.1,
            max: 10,
            onChanged: (v) => _updateScale(ref, placement, x: v, y: v, z: v),
          )
        else ...[
          _buildSliderField(
            label: 'X',
            value: placement.scale.x,
            min: 0.1,
            max: 10,
            onChanged: (v) => _updateScale(ref, placement, x: v),
          ),
          _buildSliderField(
            label: 'Y',
            value: placement.scale.y,
            min: 0.1,
            max: 10,
            onChanged: (v) => _updateScale(ref, placement, y: v),
          ),
          _buildSliderField(
            label: 'Z',
            value: placement.scale.z,
            min: 0.1,
            max: 10,
            onChanged: (v) => _updateScale(ref, placement, z: v),
          ),
        ],
      ],
    );
  }

  Widget _buildPropertyFields(WidgetRef ref, Placement placement) {
    return Column(
      children: [
        // タグ
        Wrap(
          spacing: 4,
          children: [
            ...placement.tags.map((tag) => Chip(
              label: Text(tag),
              onDeleted: () {
                final newTags = List<String>.from(placement.tags)..remove(tag);
                ref.read(placementControllerProvider).updatePlacement(
                  placement.copyWith(tags: newTags),
                  ref.read(currentProjectPathProvider)!,
                );
              },
            )),
            ActionChip(
              avatar: const Icon(Icons.add, size: 16),
              label: const Text('タグ追加'),
              onPressed: () => _showAddTagDialog(ref, placement),
            ),
          ],
        ),
        
        // 表示/非表示
        SwitchListTile(
          title: const Text('表示'),
          value: placement.visible,
          onChanged: (v) {
            ref.read(placementControllerProvider).updatePlacement(
              placement.copyWith(visible: v),
              ref.read(currentProjectPathProvider)!,
            );
          },
        ),
      ],
    );
  }

  Widget _buildActions(BuildContext context, WidgetRef ref, Placement placement) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        OutlinedButton.icon(
          onPressed: () {
            ref.read(placementControllerProvider).duplicatePlacement(
              placement.id,
              ref.read(currentProjectPathProvider)!,
            );
          },
          icon: const Icon(Icons.copy),
          label: const Text('複製'),
        ),
        OutlinedButton.icon(
          onPressed: () {
            ref.read(placementControllerProvider).zoomToPlacement(placement.id);
          },
          icon: const Icon(Icons.zoom_in),
          label: const Text('ズーム'),
        ),
        OutlinedButton.icon(
          onPressed: placement.locked
              ? null
              : () => _confirmDelete(context, ref, placement),
          icon: const Icon(Icons.delete, color: Colors.red),
          label: const Text('削除', style: TextStyle(color: Colors.red)),
        ),
      ],
    );
  }

  Widget _buildNumberField({
    required String label,
    required double value,
    String? suffix,
    required Function(double) onChanged,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          SizedBox(width: 60, child: Text(label)),
          Expanded(
            child: TextField(
              controller: TextEditingController(text: value.toStringAsFixed(6)),
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                suffixText: suffix,
                isDense: true,
              ),
              onSubmitted: (v) {
                final parsed = double.tryParse(v);
                if (parsed != null) onChanged(parsed);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSliderField({
    required String label,
    required double value,
    required double min,
    required double max,
    String? suffix,
    required Function(double) onChanged,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          SizedBox(width: 60, child: Text(label)),
          Expanded(
            child: Slider(
              value: value.clamp(min, max),
              min: min,
              max: max,
              onChanged: onChanged,
            ),
          ),
          SizedBox(
            width: 60,
            child: Text('${value.toStringAsFixed(1)}${suffix ?? ''}'),
          ),
        ],
      ),
    );
  }

  void _updatePosition(WidgetRef ref, Placement placement, {
    double? longitude,
    double? latitude,
    double? height,
  }) {
    ref.read(placementControllerProvider).updatePlacement(
      placement.copyWith(
        position: GeoPosition(
          longitude: longitude ?? placement.position.longitude,
          latitude: latitude ?? placement.position.latitude,
          height: height ?? placement.position.height,
        ),
      ),
      ref.read(currentProjectPathProvider)!,
    );
  }

  void _updateRotation(WidgetRef ref, Placement placement, {
    double? heading,
    double? pitch,
    double? roll,
  }) {
    ref.read(placementControllerProvider).updatePlacement(
      placement.copyWith(
        rotation: PlacementRotation(
          heading: heading ?? placement.rotation.heading,
          pitch: pitch ?? placement.rotation.pitch,
          roll: roll ?? placement.rotation.roll,
        ),
      ),
      ref.read(currentProjectPathProvider)!,
    );
  }

  void _updateScale(WidgetRef ref, Placement placement, {
    double? x,
    double? y,
    double? z,
  }) {
    ref.read(placementControllerProvider).updatePlacement(
      placement.copyWith(
        scale: PlacementScale(
          x: x ?? placement.scale.x,
          y: y ?? placement.scale.y,
          z: z ?? placement.scale.z,
        ),
      ),
      ref.read(currentProjectPathProvider)!,
    );
  }

  void _showAddTagDialog(WidgetRef ref, Placement placement) {
    // タグ追加ダイアログの実装
  }

  void _confirmDelete(BuildContext context, WidgetRef ref, Placement placement) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('配置物を削除'),
        content: Text('「${placement.name}」を削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('キャンセル'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () {
              Navigator.pop(context);
              ref.read(placementControllerProvider).deletePlacement(
                placement.id,
                ref.read(currentProjectPathProvider)!,
              );
            },
            child: const Text('削除'),
          ),
        ],
      ),
    );
  }
}
```

## 技術的な考慮事項

1. **パフォーマンス**
   - 大量配置物（数百個）でもスムーズに動作するようエンティティ管理を最適化
   - 選択状態の更新は差分のみを送信

2. **UX**
   - Minecraftライクな直感的操作（クリック配置、Shiftでスナップ強制）
   - リアルタイムプレビューで配置位置を確認

3. **スナップ精度**
   - 地球の曲率を考慮したグリッドスナップ計算
   - 角度スナップは設定可能（15°刻みがデフォルト）

4. **衝突判定**
   - 簡易的なバウンディングボックス衝突検出（オプション機能）
   - 警告表示のみ、配置は許可

## 成果物・完了条件

- [ ] アセット選択後にクリックで配置できる
- [ ] 配置物をドラッグで移動できる
- [ ] 回転・スケール調整が動作する
- [ ] グリッドスナップ、地面スナップが動作する
- [ ] 配置物の選択・ハイライトが動作する
- [ ] 複製（Ctrl+D）が動作する
- [ ] プロパティインスペクタで各種設定を変更できる
- [ ] placements.json に正しく保存される

## 次工程への引き継ぎ事項

- 配置物のグループ化、整列機能は必要に応じて追加
- 配置物はレイヤーとしても管理（工程07と連携）
