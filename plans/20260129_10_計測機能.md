# 工程10: 計測機能

## 目的・概要

イベント会場の設計に必要な距離・面積・高さの計測機能を実装する。ポイントをクリックして計測し、結果を保存・命名・エクスポートできるようにする。

## 対応する機能要件

- FR-40: 距離計測（2点/多点ポリライン）
- FR-41: 面積計測（ポリゴン）
- FR-42: 高さ/標高差（2点、または点→地形）
- FR-43: 周長、角度（オプション）
- FR-44: 計測結果の表示と保存（名前、色、単位、備考）
- FR-45: 計測結果のエクスポート（CSV/JSON/GeoJSON）
- FR-46: スナップ（頂点スナップ、地形スナップ）

## 実装タスク詳細

### 1. 計測データモデル

```dart
// lib/data/models/measurement.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'measurement.freezed.dart';
part 'measurement.g.dart';

/// 計測タイプ
enum MeasurementType {
  distance('距離', 'distance', Icons.straighten),
  area('面積', 'area', Icons.square_foot),
  height('高さ', 'height', Icons.height),
  angle('角度', 'angle', Icons.architecture);
  
  final String displayName;
  final String id;
  final IconData icon;
  const MeasurementType(this.displayName, this.id, this.icon);
}

/// 計測結果
@freezed
class Measurement with _$Measurement {
  const factory Measurement({
    /// 一意識別子
    required String id,
    
    /// 計測タイプ
    required MeasurementType type,
    
    /// 計測名
    required String name,
    
    /// 計測点（地理座標配列）
    required List<GeoPosition> points,
    
    /// 計測結果値
    required double value,
    
    /// 単位
    required String unit,
    
    /// 表示色（HEX）
    @Default('#FF0000') String color,
    
    /// 線の太さ
    @Default(2.0) double lineWidth,
    
    /// 表示フラグ
    @Default(true) bool visible,
    
    /// メモ・備考
    String? note,
    
    /// 作成日時
    required DateTime createdAt,
  }) = _Measurement;

  factory Measurement.fromJson(Map<String, dynamic> json) => 
      _$MeasurementFromJson(json);
  
  /// 新規計測を作成
  factory Measurement.create({
    required MeasurementType type,
    required List<GeoPosition> points,
    required double value,
    required String unit,
    String? name,
  }) {
    return Measurement(
      id: const Uuid().v4(),
      type: type,
      name: name ?? '${type.displayName} ${DateTime.now().millisecondsSinceEpoch}',
      points: points,
      value: value,
      unit: unit,
      createdAt: DateTime.now(),
    );
  }
}

/// 計測スタイル
@freezed
class MeasurementStyle with _$MeasurementStyle {
  const factory MeasurementStyle({
    @Default('#FF0000') String color,
    @Default(2.0) double lineWidth,
    @Default(true) bool showLabels,
    @Default(0.3) double fillOpacity, // 面積計測用
  }) = _MeasurementStyle;

  factory MeasurementStyle.fromJson(Map<String, dynamic> json) => 
      _$MeasurementStyleFromJson(json);
}
```

### 2. 計測リポジトリ

```dart
// lib/data/repositories/measurement_repository.dart

import 'dart:convert';
import 'dart:io';

/// 計測リポジトリ
class MeasurementRepository {
  static const String _fileName = 'measurements.json';

  /// 計測一覧を読み込み
  Future<List<Measurement>> loadMeasurements(String projectPath) async {
    final file = File(path.join(projectPath, _fileName));
    
    if (!await file.exists()) {
      return [];
    }
    
    try {
      final content = await file.readAsString();
      final json = jsonDecode(content) as List<dynamic>;
      return json
          .map((e) => Measurement.fromJson(e as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint('Failed to load measurements: $e');
      return [];
    }
  }

  /// 計測一覧を保存
  Future<void> saveMeasurements(
    String projectPath,
    List<Measurement> measurements,
  ) async {
    final file = File(path.join(projectPath, _fileName));
    final json = measurements.map((m) => m.toJson()).toList();
    await file.writeAsString(jsonEncode(json), flush: true);
  }

  /// CSV形式でエクスポート
  Future<String> exportToCsv(List<Measurement> measurements) async {
    final buffer = StringBuffer();
    
    // ヘッダ
    buffer.writeln('ID,名前,タイプ,値,単位,色,メモ,作成日時,ポイント数');
    
    // データ
    for (final m in measurements) {
      buffer.writeln([
        m.id,
        '"${m.name}"',
        m.type.displayName,
        m.value,
        m.unit,
        m.color,
        '"${m.note ?? ''}"',
        m.createdAt.toIso8601String(),
        m.points.length,
      ].join(','));
    }
    
    return buffer.toString();
  }

  /// GeoJSON形式でエクスポート
  Future<Map<String, dynamic>> exportToGeoJson(
    List<Measurement> measurements,
  ) async {
    final features = measurements.map((m) {
      Map<String, dynamic> geometry;
      
      if (m.type == MeasurementType.area) {
        // ポリゴン
        geometry = {
          'type': 'Polygon',
          'coordinates': [
            m.points.map((p) => [p.longitude, p.latitude, p.height]).toList(),
          ],
        };
      } else if (m.points.length > 1) {
        // ライン
        geometry = {
          'type': 'LineString',
          'coordinates': m.points
              .map((p) => [p.longitude, p.latitude, p.height])
              .toList(),
        };
      } else {
        // ポイント
        geometry = {
          'type': 'Point',
          'coordinates': [
            m.points.first.longitude,
            m.points.first.latitude,
            m.points.first.height,
          ],
        };
      }
      
      return {
        'type': 'Feature',
        'id': m.id,
        'geometry': geometry,
        'properties': {
          'name': m.name,
          'type': m.type.id,
          'value': m.value,
          'unit': m.unit,
          'color': m.color,
          'note': m.note,
          'createdAt': m.createdAt.toIso8601String(),
        },
      };
    }).toList();
    
    return {
      'type': 'FeatureCollection',
      'features': features,
    };
  }
}
```

### 3. cesium_bridge.js 計測機能拡張

```javascript
// assets/cesium/cesium_bridge.js に追加

/**
 * 計測管理
 */
const measurementEntities = new Map();
let measurementMode = null; // 'distance', 'area', 'height'
let measurementPoints = [];
let tempMeasurementEntity = null;

/**
 * 計測モードを開始
 * @param {string} type - 計測タイプ ('distance', 'area', 'height')
 */
function startMeasurementMode(type) {
  measurementMode = type;
  measurementPoints = [];
  
  // 一時エンティティを作成（ライン/ポリゴンプレビュー用）
  tempMeasurementEntity = viewer.entities.add({
    id: 'temp_measurement',
    polyline: type === 'area' ? undefined : {
      positions: new Cesium.CallbackProperty(() => {
        return measurementPoints.map(p => 
          Cesium.Cartesian3.fromDegrees(p.longitude, p.latitude, p.height)
        );
      }, false),
      width: 3,
      material: Cesium.Color.YELLOW,
      clampToGround: true,
    },
    polygon: type === 'area' ? {
      hierarchy: new Cesium.CallbackProperty(() => {
        return new Cesium.PolygonHierarchy(
          measurementPoints.map(p => 
            Cesium.Cartesian3.fromDegrees(p.longitude, p.latitude, p.height)
          )
        );
      }, false),
      material: Cesium.Color.YELLOW.withAlpha(0.3),
      outline: true,
      outlineColor: Cesium.Color.YELLOW,
      outlineWidth: 3,
    } : undefined,
  });
  
  // クリックイベント
  viewer.screenSpaceEventHandler.setInputAction((click) => {
    if (!measurementMode) return;
    
    const position = getGroundPosition(click.position);
    if (position) {
      const cartographic = Cesium.Cartographic.fromCartesian(position);
      const point = {
        longitude: Cesium.Math.toDegrees(cartographic.longitude),
        latitude: Cesium.Math.toDegrees(cartographic.latitude),
        height: cartographic.height,
      };
      
      measurementPoints.push(point);
      
      // ポイントマーカーを追加
      viewer.entities.add({
        id: 'measure_point_' + measurementPoints.length,
        position: position,
        point: {
          pixelSize: 10,
          color: Cesium.Color.YELLOW,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
        },
      });
      
      // 高さ計測は2点で完了
      if (measurementMode === 'height' && measurementPoints.length === 2) {
        finishMeasurement();
      }
      
      sendToFlutter('measurementPointAdded', {
        points: measurementPoints,
        currentValue: calculateMeasurement(),
      });
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
  
  // ダブルクリックで確定
  viewer.screenSpaceEventHandler.setInputAction(() => {
    if (!measurementMode) return;
    if (measurementPoints.length >= 2) {
      finishMeasurement();
    }
  }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
  
  // 右クリックでキャンセル
  viewer.screenSpaceEventHandler.setInputAction(() => {
    cancelMeasurement();
  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
}

/**
 * 計測を確定
 */
function finishMeasurement() {
  const value = calculateMeasurement();
  const unit = getMeasurementUnit();
  
  sendToFlutter('measurementCompleted', {
    type: measurementMode,
    points: measurementPoints,
    value: value,
    unit: unit,
  });
  
  cleanupTempMeasurement();
  measurementMode = null;
}

/**
 * 計測をキャンセル
 */
function cancelMeasurement() {
  cleanupTempMeasurement();
  measurementMode = null;
  measurementPoints = [];
  
  sendToFlutter('measurementCancelled', {});
}

/**
 * 一時エンティティをクリーンアップ
 */
function cleanupTempMeasurement() {
  if (tempMeasurementEntity) {
    viewer.entities.remove(tempMeasurementEntity);
    tempMeasurementEntity = null;
  }
  
  // ポイントマーカーを削除
  for (let i = 1; i <= measurementPoints.length; i++) {
    const entity = viewer.entities.getById('measure_point_' + i);
    if (entity) {
      viewer.entities.remove(entity);
    }
  }
}

/**
 * 計測値を計算
 * @returns {number} 計測値
 */
function calculateMeasurement() {
  if (measurementPoints.length < 2) return 0;
  
  switch (measurementMode) {
    case 'distance':
      return calculateDistance();
    case 'area':
      return calculateArea();
    case 'height':
      return calculateHeight();
    default:
      return 0;
  }
}

/**
 * 距離を計算（メートル）
 */
function calculateDistance() {
  let totalDistance = 0;
  
  for (let i = 0; i < measurementPoints.length - 1; i++) {
    const p1 = measurementPoints[i];
    const p2 = measurementPoints[i + 1];
    
    const geodesic = new Cesium.EllipsoidGeodesic(
      Cesium.Cartographic.fromDegrees(p1.longitude, p1.latitude),
      Cesium.Cartographic.fromDegrees(p2.longitude, p2.latitude)
    );
    
    // 水平距離
    const horizontalDistance = geodesic.surfaceDistance;
    
    // 高さの差
    const heightDiff = p2.height - p1.height;
    
    // 3D距離
    totalDistance += Math.sqrt(
      horizontalDistance * horizontalDistance + heightDiff * heightDiff
    );
  }
  
  return totalDistance;
}

/**
 * 面積を計算（平方メートル）
 */
function calculateArea() {
  if (measurementPoints.length < 3) return 0;
  
  const positions = measurementPoints.map(p => 
    Cesium.Cartographic.fromDegrees(p.longitude, p.latitude)
  );
  
  // 球面三角形の面積計算
  // 簡易実装：平面近似
  let area = 0;
  const n = positions.length;
  
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    
    const x1 = positions[i].longitude * 111320 * Math.cos(positions[i].latitude);
    const y1 = positions[i].latitude * 110540;
    const x2 = positions[j].longitude * 111320 * Math.cos(positions[j].latitude);
    const y2 = positions[j].latitude * 110540;
    
    area += x1 * y2 - x2 * y1;
  }
  
  return Math.abs(area) / 2;
}

/**
 * 高さ/標高差を計算（メートル）
 */
function calculateHeight() {
  if (measurementPoints.length < 2) return 0;
  
  const p1 = measurementPoints[0];
  const p2 = measurementPoints[1];
  
  return Math.abs(p2.height - p1.height);
}

/**
 * 計測単位を取得
 */
function getMeasurementUnit() {
  switch (measurementMode) {
    case 'distance':
      return 'm';
    case 'area':
      return 'm²';
    case 'height':
      return 'm';
    default:
      return '';
  }
}

/**
 * 計測結果を表示
 * @param {Object} measurement - 計測データ
 */
function addMeasurementDisplay(measurement) {
  const positions = measurement.points.map(p => 
    Cesium.Cartesian3.fromDegrees(p.longitude, p.latitude, p.height)
  );
  
  const color = Cesium.Color.fromCssColorString(measurement.color);
  
  let entity;
  
  if (measurement.type === 'area') {
    entity = viewer.entities.add({
      id: measurement.id,
      name: measurement.name,
      polygon: {
        hierarchy: new Cesium.PolygonHierarchy(positions),
        material: color.withAlpha(0.3),
        outline: true,
        outlineColor: color,
        outlineWidth: measurement.lineWidth,
      },
      label: {
        text: `${measurement.name}\n${measurement.value.toFixed(2)} ${measurement.unit}`,
        font: '14px sans-serif',
        fillColor: Cesium.Color.WHITE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 2,
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        position: getCentroid(positions),
      },
    });
  } else {
    entity = viewer.entities.add({
      id: measurement.id,
      name: measurement.name,
      polyline: {
        positions: positions,
        width: measurement.lineWidth,
        material: color,
        clampToGround: measurement.type !== 'height',
      },
      label: {
        text: `${measurement.name}\n${measurement.value.toFixed(2)} ${measurement.unit}`,
        font: '14px sans-serif',
        fillColor: Cesium.Color.WHITE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 2,
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        position: getMidpoint(positions),
      },
    });
    
    // 端点マーカー
    positions.forEach((pos, i) => {
      viewer.entities.add({
        id: `${measurement.id}_point_${i}`,
        position: pos,
        point: {
          pixelSize: 8,
          color: color,
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 2,
        },
      });
    });
  }
  
  measurementEntities.set(measurement.id, entity);
}

/**
 * 計測結果を削除
 * @param {string} measurementId - 計測ID
 */
function removeMeasurementDisplay(measurementId) {
  const entity = measurementEntities.get(measurementId);
  if (entity) {
    viewer.entities.remove(entity);
    measurementEntities.delete(measurementId);
    
    // 端点マーカーも削除
    let i = 0;
    while (true) {
      const pointEntity = viewer.entities.getById(`${measurementId}_point_${i}`);
      if (!pointEntity) break;
      viewer.entities.remove(pointEntity);
      i++;
    }
  }
}

/**
 * 計測結果の表示/非表示を切り替え
 */
function setMeasurementVisible(measurementId, visible) {
  const entity = measurementEntities.get(measurementId);
  if (entity) {
    entity.show = visible;
  }
}

/**
 * 中点を取得
 */
function getMidpoint(positions) {
  if (positions.length === 0) return Cesium.Cartesian3.ZERO;
  if (positions.length === 1) return positions[0];
  
  const midIndex = Math.floor(positions.length / 2);
  return positions[midIndex];
}

/**
 * 重心を取得
 */
function getCentroid(positions) {
  if (positions.length === 0) return Cesium.Cartesian3.ZERO;
  
  let x = 0, y = 0, z = 0;
  positions.forEach(p => {
    x += p.x;
    y += p.y;
    z += p.z;
  });
  
  return new Cesium.Cartesian3(
    x / positions.length,
    y / positions.length,
    z / positions.length
  );
}

// handleFlutterMessage に追加
function handleFlutterMessage(method, params) {
  switch (method) {
    // ... 既存のcase
    
    case 'startMeasurementMode':
      startMeasurementMode(params.type);
      break;
    case 'cancelMeasurement':
      cancelMeasurement();
      break;
    case 'addMeasurementDisplay':
      addMeasurementDisplay(params);
      break;
    case 'removeMeasurementDisplay':
      removeMeasurementDisplay(params.measurementId);
      break;
    case 'setMeasurementVisible':
      setMeasurementVisible(params.measurementId, params.visible);
      break;
  }
}
```

### 4. Flutter側 MeasurementController

```dart
// lib/infrastructure/webview/measurement_controller.dart

/// 計測コントローラ
class MeasurementController extends ChangeNotifier {
  final CesiumController _cesiumController;
  final MeasurementRepository _repository;
  
  final List<Measurement> _measurements = [];
  MeasurementType? _currentMode;
  List<GeoPosition> _tempPoints = [];
  double _currentValue = 0;
  
  List<Measurement> get measurements => List.unmodifiable(_measurements);
  MeasurementType? get currentMode => _currentMode;
  List<GeoPosition> get tempPoints => List.unmodifiable(_tempPoints);
  double get currentValue => _currentValue;

  MeasurementController(this._cesiumController, this._repository) {
    _cesiumController.onMeasurementPointAdded = _onMeasurementPointAdded;
    _cesiumController.onMeasurementCompleted = _onMeasurementCompleted;
    _cesiumController.onMeasurementCancelled = _onMeasurementCancelled;
  }

  /// 計測一覧を読み込み
  Future<void> loadMeasurements(String projectPath) async {
    _measurements.clear();
    _measurements.addAll(await _repository.loadMeasurements(projectPath));
    
    // CesiumJSに表示
    for (final measurement in _measurements) {
      await _addMeasurementToCesium(measurement);
    }
    
    notifyListeners();
  }

  /// 計測モードを開始
  Future<void> startMeasurement(MeasurementType type) async {
    _currentMode = type;
    _tempPoints = [];
    _currentValue = 0;
    
    await _cesiumController.executeMethod('startMeasurementMode', {
      'type': type.id,
    });
    
    notifyListeners();
  }

  /// 計測をキャンセル
  Future<void> cancelMeasurement() async {
    _currentMode = null;
    _tempPoints = [];
    _currentValue = 0;
    
    await _cesiumController.executeMethod('cancelMeasurement', {});
    
    notifyListeners();
  }

  /// 計測を削除
  Future<void> deleteMeasurement(
    String measurementId,
    String projectPath,
  ) async {
    await _cesiumController.executeMethod('removeMeasurementDisplay', {
      'measurementId': measurementId,
    });
    
    _measurements.removeWhere((m) => m.id == measurementId);
    await _repository.saveMeasurements(projectPath, _measurements);
    
    notifyListeners();
  }

  /// 計測を更新
  Future<void> updateMeasurement(
    Measurement measurement,
    String projectPath,
  ) async {
    final index = _measurements.indexWhere((m) => m.id == measurement.id);
    if (index == -1) return;
    
    _measurements[index] = measurement;
    await _repository.saveMeasurements(projectPath, _measurements);
    
    // 表示を更新
    await _cesiumController.executeMethod('removeMeasurementDisplay', {
      'measurementId': measurement.id,
    });
    await _addMeasurementToCesium(measurement);
    
    notifyListeners();
  }

  /// 表示/非表示を切り替え
  Future<void> setMeasurementVisible(
    String measurementId,
    bool visible,
  ) async {
    final index = _measurements.indexWhere((m) => m.id == measurementId);
    if (index == -1) return;
    
    _measurements[index] = _measurements[index].copyWith(visible: visible);
    
    await _cesiumController.executeMethod('setMeasurementVisible', {
      'measurementId': measurementId,
      'visible': visible,
    });
    
    notifyListeners();
  }

  /// CSVエクスポート
  Future<String> exportToCsv() async {
    return await _repository.exportToCsv(_measurements);
  }

  /// GeoJSONエクスポート
  Future<Map<String, dynamic>> exportToGeoJson() async {
    return await _repository.exportToGeoJson(_measurements);
  }

  // コールバック

  void _onMeasurementPointAdded(Map<String, dynamic> data) {
    _tempPoints = (data['points'] as List)
        .map((p) => GeoPosition.fromJson(p as Map<String, dynamic>))
        .toList();
    _currentValue = (data['currentValue'] as num).toDouble();
    notifyListeners();
  }

  void _onMeasurementCompleted(Map<String, dynamic> data) async {
    final type = MeasurementType.values.firstWhere(
      (t) => t.id == data['type'],
    );
    final points = (data['points'] as List)
        .map((p) => GeoPosition.fromJson(p as Map<String, dynamic>))
        .toList();
    final value = (data['value'] as num).toDouble();
    final unit = data['unit'] as String;
    
    final measurement = Measurement.create(
      type: type,
      points: points,
      value: value,
      unit: unit,
    );
    
    _measurements.add(measurement);
    await _addMeasurementToCesium(measurement);
    
    _currentMode = null;
    _tempPoints = [];
    _currentValue = 0;
    
    notifyListeners();
  }

  void _onMeasurementCancelled(Map<String, dynamic> data) {
    _currentMode = null;
    _tempPoints = [];
    _currentValue = 0;
    notifyListeners();
  }

  Future<void> _addMeasurementToCesium(Measurement measurement) async {
    await _cesiumController.executeMethod('addMeasurementDisplay', 
        measurement.toJson());
  }
}
```

### 5. 計測パネルUI

```dart
// lib/presentation/widgets/measurement_panel.dart

/// 計測パネル
class MeasurementPanel extends ConsumerWidget {
  const MeasurementPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = ref.watch(measurementControllerProvider);
    final currentMode = controller.currentMode;
    final measurements = controller.measurements;
    
    return Column(
      children: [
        // ツールバー
        _buildToolbar(context, ref, currentMode),
        
        // 計測中の表示
        if (currentMode != null)
          _buildMeasuringIndicator(ref, currentMode),
        
        const Divider(height: 1),
        
        // 計測一覧
        Expanded(
          child: measurements.isEmpty
              ? const Center(child: Text('計測結果がありません'))
              : ListView.builder(
                  itemCount: measurements.length,
                  itemBuilder: (context, index) {
                    return _MeasurementTile(
                      measurement: measurements[index],
                    );
                  },
                ),
        ),
        
        // エクスポートボタン
        if (measurements.isNotEmpty)
          _buildExportBar(context, ref),
      ],
    );
  }

  Widget _buildToolbar(
    BuildContext context,
    WidgetRef ref,
    MeasurementType? currentMode,
  ) {
    return Padding(
      padding: const EdgeInsets.all(8),
      child: Row(
        children: [
          const Text('計測', style: TextStyle(fontWeight: FontWeight.bold)),
          const Spacer(),
          _buildToolButton(
            icon: Icons.straighten,
            label: '距離',
            isActive: currentMode == MeasurementType.distance,
            onPressed: () {
              if (currentMode != null) {
                ref.read(measurementControllerProvider).cancelMeasurement();
              }
              ref.read(measurementControllerProvider)
                  .startMeasurement(MeasurementType.distance);
            },
          ),
          _buildToolButton(
            icon: Icons.square_foot,
            label: '面積',
            isActive: currentMode == MeasurementType.area,
            onPressed: () {
              if (currentMode != null) {
                ref.read(measurementControllerProvider).cancelMeasurement();
              }
              ref.read(measurementControllerProvider)
                  .startMeasurement(MeasurementType.area);
            },
          ),
          _buildToolButton(
            icon: Icons.height,
            label: '高さ',
            isActive: currentMode == MeasurementType.height,
            onPressed: () {
              if (currentMode != null) {
                ref.read(measurementControllerProvider).cancelMeasurement();
              }
              ref.read(measurementControllerProvider)
                  .startMeasurement(MeasurementType.height);
            },
          ),
        ],
      ),
    );
  }

  Widget _buildToolButton({
    required IconData icon,
    required String label,
    required bool isActive,
    required VoidCallback onPressed,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 2),
      child: Tooltip(
        message: label,
        child: IconButton(
          icon: Icon(icon),
          color: isActive ? Theme.of(context).primaryColor : null,
          style: IconButton.styleFrom(
            backgroundColor: isActive 
                ? Theme.of(context).primaryColor.withOpacity(0.2)
                : null,
          ),
          onPressed: onPressed,
        ),
      ),
    );
  }

  Widget _buildMeasuringIndicator(WidgetRef ref, MeasurementType mode) {
    final controller = ref.watch(measurementControllerProvider);
    final pointCount = controller.tempPoints.length;
    final currentValue = controller.currentValue;
    
    String instruction;
    switch (mode) {
      case MeasurementType.distance:
        instruction = 'クリックで点を追加、ダブルクリックで確定';
        break;
      case MeasurementType.area:
        instruction = 'クリックで頂点を追加、ダブルクリックで確定';
        break;
      case MeasurementType.height:
        instruction = '2点をクリックして高さを計測';
        break;
      default:
        instruction = '';
    }
    
    return Container(
      padding: const EdgeInsets.all(12),
      color: Colors.yellow.withOpacity(0.2),
      child: Row(
        children: [
          Icon(mode.icon, size: 20),
          const SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('${mode.displayName}計測中'),
                Text(instruction, style: const TextStyle(fontSize: 12)),
              ],
            ),
          ),
          if (pointCount > 0) ...[
            Text(
              '${currentValue.toStringAsFixed(2)} ${_getUnit(mode)}',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(width: 8),
          ],
          TextButton(
            onPressed: () {
              ref.read(measurementControllerProvider).cancelMeasurement();
            },
            child: const Text('キャンセル'),
          ),
        ],
      ),
    );
  }

  Widget _buildExportBar(BuildContext context, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.all(8),
      child: Row(
        children: [
          TextButton.icon(
            icon: const Icon(Icons.download, size: 16),
            label: const Text('CSV'),
            onPressed: () => _exportCsv(context, ref),
          ),
          TextButton.icon(
            icon: const Icon(Icons.download, size: 16),
            label: const Text('GeoJSON'),
            onPressed: () => _exportGeoJson(context, ref),
          ),
        ],
      ),
    );
  }

  String _getUnit(MeasurementType type) {
    switch (type) {
      case MeasurementType.distance:
        return 'm';
      case MeasurementType.area:
        return 'm²';
      case MeasurementType.height:
        return 'm';
      default:
        return '';
    }
  }

  Future<void> _exportCsv(BuildContext context, WidgetRef ref) async {
    final csv = await ref.read(measurementControllerProvider).exportToCsv();
    
    final result = await FilePicker.platform.saveFile(
      dialogTitle: 'CSV保存先を選択',
      fileName: 'measurements.csv',
    );
    
    if (result != null) {
      await File(result).writeAsString(csv);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('CSVを保存しました')),
      );
    }
  }

  Future<void> _exportGeoJson(BuildContext context, WidgetRef ref) async {
    final geoJson = await ref.read(measurementControllerProvider)
        .exportToGeoJson();
    
    final result = await FilePicker.platform.saveFile(
      dialogTitle: 'GeoJSON保存先を選択',
      fileName: 'measurements.geojson',
    );
    
    if (result != null) {
      await File(result).writeAsString(jsonEncode(geoJson));
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('GeoJSONを保存しました')),
      );
    }
  }
}

/// 計測タイル
class _MeasurementTile extends ConsumerWidget {
  final Measurement measurement;

  const _MeasurementTile({required this.measurement});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: Icon(
        measurement.type.icon,
        color: Color(int.parse(
            measurement.color.replaceFirst('#', '0xFF'))),
      ),
      title: Text(measurement.name),
      subtitle: Text(
        '${measurement.value.toStringAsFixed(2)} ${measurement.unit}',
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: Icon(
              measurement.visible ? Icons.visibility : Icons.visibility_off,
              size: 20,
            ),
            onPressed: () {
              ref.read(measurementControllerProvider).setMeasurementVisible(
                measurement.id,
                !measurement.visible,
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete, size: 20),
            onPressed: () {
              ref.read(measurementControllerProvider).deleteMeasurement(
                measurement.id,
                ref.read(currentProjectPathProvider)!,
              );
            },
          ),
        ],
      ),
      onTap: () => _showEditDialog(context, ref),
    );
  }

  void _showEditDialog(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => _MeasurementEditDialog(
        measurement: measurement,
        onSave: (updated) {
          ref.read(measurementControllerProvider).updateMeasurement(
            updated,
            ref.read(currentProjectPathProvider)!,
          );
        },
      ),
    );
  }
}
```

## 技術的な考慮事項

1. **精度**
   - 地球の曲率を考慮した測地線距離計算
   - 面積計算は平面近似（小さな範囲では十分な精度）

2. **UX**
   - リアルタイム計測値プレビュー
   - クリック連打で折れ線、ダブルクリックで確定

3. **単位変換**
   - m/ft、m²/ft²/ha/acreの切り替え対応

## 成果物・完了条件

- [ ] 距離計測が動作する（2点/ポリライン）
- [ ] 面積計測が動作する
- [ ] 高さ計測が動作する
- [ ] 計測結果がラベル表示される
- [ ] 計測結果の保存・読み込みが動作する
- [ ] CSV/GeoJSONエクスポートが動作する

## 次工程への引き継ぎ事項

- 計測結果はレイヤーとしても管理（工程07と連携）
- 計測設定の保存はプロジェクト設定に含める
