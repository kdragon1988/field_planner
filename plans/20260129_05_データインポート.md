# 工程05: 3Dデータ・点群インポート

## 目的・概要

DJI Terra等から出力された3Dデータ（メッシュ）および点群を取り込む機能を実装する。対応フォーマットの読み込み、ファイル選択ダイアログ、ジオリファレンス情報の読み取り、インポートキュー管理を行う。

## 対応する機能要件

- FR-10: 対応入力フォーマット
  - 点群: LAS/LAZ、PLY（点）、E57
  - メッシュ: OBJ/MTL、FBX、glTF/GLB
- FR-12: 座標系/位置合わせ（ジオリファレンス情報読み取り）

## 実装タスク詳細

### 1. サポートフォーマット定義

```dart
// lib/data/models/import_format.dart

/// インポート対応フォーマット
enum ImportFormat {
  // 点群フォーマット
  las('LAS', '.las', ImportCategory.pointCloud, 'ASPRS LAS点群'),
  laz('LAZ', '.laz', ImportCategory.pointCloud, 'ASPRS LAZ圧縮点群'),
  plyPoints('PLY (点群)', '.ply', ImportCategory.pointCloud, 'PLY点群'),
  e57('E57', '.e57', ImportCategory.pointCloud, 'E57点群'),
  
  // メッシュフォーマット
  obj('OBJ', '.obj', ImportCategory.mesh, 'Wavefront OBJメッシュ'),
  fbx('FBX', '.fbx', ImportCategory.mesh, 'Autodesk FBXメッシュ'),
  gltf('glTF', '.gltf', ImportCategory.mesh, 'glTF 2.0'),
  glb('GLB', '.glb', ImportCategory.mesh, 'glTF Binaryメッシュ'),
  
  // 3D Tiles（変換済み）
  tiles3d('3D Tiles', 'tileset.json', ImportCategory.tiles3d, 'Cesium 3D Tiles');

  final String displayName;
  final String extension;
  final ImportCategory category;
  final String description;
  
  const ImportFormat(this.displayName, this.extension, this.category, this.description);
  
  /// 拡張子からフォーマットを判定
  static ImportFormat? fromExtension(String ext) {
    final lowerExt = ext.toLowerCase();
    return ImportFormat.values.firstWhere(
      (f) => f.extension == lowerExt,
      orElse: () => throw UnsupportedFormatException(ext),
    );
  }
  
  /// ファイルダイアログ用フィルタ
  static List<String> get allExtensions => 
      ImportFormat.values.map((f) => f.extension).toList();
  
  static List<String> get pointCloudExtensions =>
      ImportFormat.values
          .where((f) => f.category == ImportCategory.pointCloud)
          .map((f) => f.extension)
          .toList();
  
  static List<String> get meshExtensions =>
      ImportFormat.values
          .where((f) => f.category == ImportCategory.mesh)
          .map((f) => f.extension)
          .toList();
}

/// インポートカテゴリ
enum ImportCategory {
  pointCloud('点群'),
  mesh('メッシュ'),
  tiles3d('3D Tiles');
  
  final String displayName;
  const ImportCategory(this.displayName);
}

/// 未対応フォーマット例外
class UnsupportedFormatException implements Exception {
  final String extension;
  UnsupportedFormatException(this.extension);
  
  @override
  String toString() => '未対応のフォーマットです: $extension';
}
```

### 2. インポートジョブモデル

```dart
// lib/data/models/import_job.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'import_job.freezed.dart';
part 'import_job.g.dart';

/// インポートジョブ状態
enum ImportJobStatus {
  pending('待機中'),
  analyzing('解析中'),
  converting('変換中'),
  copying('コピー中'),
  completed('完了'),
  failed('失敗'),
  cancelled('キャンセル');
  
  final String displayName;
  const ImportJobStatus(this.displayName);
}

/// インポートジョブ
@freezed
class ImportJob with _$ImportJob {
  const factory ImportJob({
    required String id,
    required String sourcePath,
    required String fileName,
    required ImportFormat format,
    required ImportJobStatus status,
    @Default(0.0) double progress,
    String? errorMessage,
    String? outputPath,
    GeoReference? geoReference,
    DateTime? startedAt,
    DateTime? completedAt,
    ImportOptions? options,
  }) = _ImportJob;

  factory ImportJob.fromJson(Map<String, dynamic> json) => 
      _$ImportJobFromJson(json);
      
  factory ImportJob.create({
    required String sourcePath,
    ImportOptions? options,
  }) {
    final fileName = path.basename(sourcePath);
    final ext = path.extension(sourcePath);
    
    return ImportJob(
      id: const Uuid().v4(),
      sourcePath: sourcePath,
      fileName: fileName,
      format: ImportFormat.fromExtension(ext),
      status: ImportJobStatus.pending,
      options: options,
    );
  }
}

/// インポートオプション
@freezed
class ImportOptions with _$ImportOptions {
  const factory ImportOptions({
    /// 元ファイルをプロジェクトにコピーするか
    @Default(true) bool copyToProject,
    
    /// 3D Tilesへの自動変換を行うか
    @Default(true) bool autoConvert,
    
    /// 点群のダウンサンプリング率 (0.0-1.0)
    @Default(1.0) double downsampleRatio,
    
    /// 座標系 (EPSG)
    int? sourceEpsg,
    
    /// 手動オフセット
    Offset3D? manualOffset,
  }) = _ImportOptions;

  factory ImportOptions.fromJson(Map<String, dynamic> json) => 
      _$ImportOptionsFromJson(json);
}

/// ジオリファレンス情報
@freezed
class GeoReference with _$GeoReference {
  const factory GeoReference({
    /// 座標系 (EPSG)
    int? epsg,
    
    /// 原点座標
    GeoPosition? origin,
    
    /// 変換行列
    List<double>? transformMatrix,
    
    /// バウンディングボックス
    BoundingBox? boundingBox,
    
    /// 検出方法
    @Default('auto') String detectionMethod,
  }) = _GeoReference;

  factory GeoReference.fromJson(Map<String, dynamic> json) => 
      _$GeoReferenceFromJson(json);
}

/// バウンディングボックス
@freezed
class BoundingBox with _$BoundingBox {
  const factory BoundingBox({
    required double minX,
    required double minY,
    required double minZ,
    required double maxX,
    required double maxY,
    required double maxZ,
  }) = _BoundingBox;

  factory BoundingBox.fromJson(Map<String, dynamic> json) => 
      _$BoundingBoxFromJson(json);
      
  double get width => maxX - minX;
  double get height => maxY - minY;
  double get depth => maxZ - minZ;
  
  GeoPosition get center => GeoPosition(
    longitude: (minX + maxX) / 2,
    latitude: (minY + maxY) / 2,
    height: (minZ + maxZ) / 2,
  );
}
```

### 3. ファイル解析サービス

```dart
// lib/data/services/file_analyzer_service.dart

import 'dart:io';
import 'dart:typed_data';

/// ファイル解析サービス
/// 
/// インポートファイルのヘッダ情報を解析し、
/// ジオリファレンス情報等を抽出する
class FileAnalyzerService {
  
  /// ファイルを解析してジオリファレンス情報を取得
  Future<GeoReference?> analyzeFile(String filePath) async {
    final ext = path.extension(filePath).toLowerCase();
    
    switch (ext) {
      case '.las':
      case '.laz':
        return await _analyzeLas(filePath);
      case '.ply':
        return await _analyzePly(filePath);
      case '.obj':
        return await _analyzeObj(filePath);
      case '.gltf':
      case '.glb':
        return await _analyzeGltf(filePath);
      default:
        return null;
    }
  }
  
  /// LAS/LAZファイルの解析
  Future<GeoReference?> _analyzeLas(String filePath) async {
    final file = File(filePath);
    final bytes = await file.openRead(0, 375).toList();
    final header = bytes.expand((b) => b).toList();
    
    if (header.length < 375) return null;
    
    // LAS 1.4 Header解析
    final byteData = ByteData.sublistView(Uint8List.fromList(header));
    
    // File Signature確認
    final signature = String.fromCharCodes(header.sublist(0, 4));
    if (signature != 'LASF') return null;
    
    // Version
    final versionMajor = header[24];
    final versionMinor = header[25];
    
    // Point Data Format
    final pointFormat = header[104];
    
    // Scale Factors
    final scaleX = byteData.getFloat64(131, Endian.little);
    final scaleY = byteData.getFloat64(139, Endian.little);
    final scaleZ = byteData.getFloat64(147, Endian.little);
    
    // Offsets
    final offsetX = byteData.getFloat64(155, Endian.little);
    final offsetY = byteData.getFloat64(163, Endian.little);
    final offsetZ = byteData.getFloat64(171, Endian.little);
    
    // Bounding Box
    final maxX = byteData.getFloat64(179, Endian.little);
    final minX = byteData.getFloat64(187, Endian.little);
    final maxY = byteData.getFloat64(195, Endian.little);
    final minY = byteData.getFloat64(203, Endian.little);
    final maxZ = byteData.getFloat64(211, Endian.little);
    final minZ = byteData.getFloat64(219, Endian.little);
    
    // VLR（Variable Length Records）からCRS情報を取得
    int? epsg;
    // TODO: VLRパース実装（WKT/GeoTIFF形式のCRS情報）
    
    return GeoReference(
      epsg: epsg,
      origin: GeoPosition(
        longitude: offsetX,
        latitude: offsetY,
        height: offsetZ,
      ),
      boundingBox: BoundingBox(
        minX: minX,
        minY: minY,
        minZ: minZ,
        maxX: maxX,
        maxY: maxY,
        maxZ: maxZ,
      ),
      detectionMethod: 'las_header',
    );
  }
  
  /// PLYファイルの解析
  Future<GeoReference?> _analyzePly(String filePath) async {
    final file = File(filePath);
    final lines = await file.openRead()
        .transform(utf8.decoder)
        .transform(const LineSplitter())
        .take(100) // ヘッダ部分のみ読み取り
        .toList();
    
    // PLYヘッダ解析
    bool hasGeoRef = false;
    int vertexCount = 0;
    
    for (final line in lines) {
      if (line.startsWith('element vertex')) {
        vertexCount = int.parse(line.split(' ').last);
      }
      if (line.contains('comment') && line.contains('EPSG')) {
        // コメントからEPSG情報を取得（非標準）
        hasGeoRef = true;
      }
      if (line == 'end_header') break;
    }
    
    // PLYは標準ではジオリファレンス情報を持たない
    return hasGeoRef ? GeoReference(detectionMethod: 'ply_comment') : null;
  }
  
  /// OBJファイルの解析
  Future<GeoReference?> _analyzeObj(String filePath) async {
    // OBJは標準ではジオリファレンス情報を持たない
    // 付随するファイル（.prj等）を探す
    final prjPath = filePath.replaceAll('.obj', '.prj');
    if (await File(prjPath).exists()) {
      final wkt = await File(prjPath).readAsString();
      // WKT解析してEPSGを取得
      return GeoReference(
        detectionMethod: 'prj_file',
      );
    }
    return null;
  }
  
  /// glTF/GLBファイルの解析
  Future<GeoReference?> _analyzeGltf(String filePath) async {
    // glTFの拡張機能からジオリファレンス情報を探す
    // 例: CESIUM_RTC拡張
    
    final ext = path.extension(filePath).toLowerCase();
    
    if (ext == '.glb') {
      // GLBバイナリ解析
      // TODO: 実装
    } else {
      // glTF JSON解析
      final file = File(filePath);
      final content = await file.readAsString();
      final json = jsonDecode(content) as Map<String, dynamic>;
      
      // extensionsから位置情報を探す
      if (json.containsKey('extensions')) {
        final extensions = json['extensions'] as Map<String, dynamic>;
        if (extensions.containsKey('CESIUM_RTC')) {
          final rtc = extensions['CESIUM_RTC'] as Map<String, dynamic>;
          final center = rtc['center'] as List<dynamic>;
          return GeoReference(
            origin: GeoPosition(
              longitude: center[0].toDouble(),
              latitude: center[1].toDouble(),
              height: center[2].toDouble(),
            ),
            detectionMethod: 'gltf_cesium_rtc',
          );
        }
      }
    }
    
    return null;
  }
  
  /// ファイルサイズを取得
  Future<int> getFileSize(String filePath) async {
    final file = File(filePath);
    return await file.length();
  }
  
  /// 点群の概算点数を取得
  Future<int?> estimatePointCount(String filePath) async {
    final ext = path.extension(filePath).toLowerCase();
    
    if (ext == '.las' || ext == '.laz') {
      final file = File(filePath);
      final bytes = await file.openRead(0, 247).toList();
      final header = bytes.expand((b) => b).toList();
      
      if (header.length >= 247) {
        final byteData = ByteData.sublistView(Uint8List.fromList(header));
        // Legacy Point Count (32-bit)
        return byteData.getUint32(107, Endian.little);
      }
    }
    
    return null;
  }
}
```

### 4. インポートサービス

```dart
// lib/data/services/import_service.dart

import 'dart:async';
import 'dart:io';

/// インポートサービス
/// 
/// ファイルインポートの全体フローを管理する
class ImportService {
  final FileAnalyzerService _analyzerService;
  final ProjectRepository _projectRepository;
  
  final _jobStreamController = StreamController<ImportJob>.broadcast();
  final Map<String, ImportJob> _jobs = {};
  
  Stream<ImportJob> get jobStream => _jobStreamController.stream;
  List<ImportJob> get activeJobs => _jobs.values.toList();

  ImportService(this._analyzerService, this._projectRepository);

  /// インポートジョブを作成して開始
  Future<ImportJob> startImport({
    required String sourcePath,
    required String projectPath,
    ImportOptions options = const ImportOptions(),
  }) async {
    // ジョブ作成
    var job = ImportJob.create(
      sourcePath: sourcePath,
      options: options,
    );
    
    _jobs[job.id] = job;
    _notifyJobUpdate(job);
    
    try {
      // 1. ファイル解析
      job = job.copyWith(
        status: ImportJobStatus.analyzing,
        startedAt: DateTime.now(),
      );
      _notifyJobUpdate(job);
      
      final geoRef = await _analyzerService.analyzeFile(sourcePath);
      job = job.copyWith(geoReference: geoRef);
      _notifyJobUpdate(job);
      
      // 2. ファイルコピー（オプション）
      String targetPath = sourcePath;
      if (options.copyToProject) {
        job = job.copyWith(status: ImportJobStatus.copying);
        _notifyJobUpdate(job);
        
        targetPath = await _copyToProject(sourcePath, projectPath);
      }
      
      // 3. 出力パス設定
      job = job.copyWith(
        outputPath: targetPath,
        status: ImportJobStatus.completed,
        completedAt: DateTime.now(),
        progress: 1.0,
      );
      _notifyJobUpdate(job);
      
    } catch (e) {
      job = job.copyWith(
        status: ImportJobStatus.failed,
        errorMessage: e.toString(),
        completedAt: DateTime.now(),
      );
      _notifyJobUpdate(job);
    }
    
    return job;
  }

  /// インポートジョブをキャンセル
  void cancelImport(String jobId) {
    final job = _jobs[jobId];
    if (job != null && job.status == ImportJobStatus.pending) {
      _jobs[jobId] = job.copyWith(
        status: ImportJobStatus.cancelled,
        completedAt: DateTime.now(),
      );
      _notifyJobUpdate(_jobs[jobId]!);
    }
  }

  /// ファイルをプロジェクトフォルダにコピー
  Future<String> _copyToProject(String sourcePath, String projectPath) async {
    final fileName = path.basename(sourcePath);
    final importsDir = path.join(projectPath, 'imports');
    
    await Directory(importsDir).create(recursive: true);
    
    final targetPath = path.join(importsDir, fileName);
    
    // ファイルコピー
    await File(sourcePath).copy(targetPath);
    
    // 関連ファイルもコピー（MTL, テクスチャ等）
    await _copyRelatedFiles(sourcePath, importsDir);
    
    return targetPath;
  }

  /// 関連ファイルをコピー（OBJ→MTL, テクスチャ等）
  Future<void> _copyRelatedFiles(String mainFile, String targetDir) async {
    final ext = path.extension(mainFile).toLowerCase();
    final dir = path.dirname(mainFile);
    final baseName = path.basenameWithoutExtension(mainFile);
    
    if (ext == '.obj') {
      // MTLファイル
      final mtlPath = path.join(dir, '$baseName.mtl');
      if (await File(mtlPath).exists()) {
        await File(mtlPath).copy(path.join(targetDir, '$baseName.mtl'));
        
        // MTL内のテクスチャファイルを解析してコピー
        await _copyMtlTextures(mtlPath, dir, targetDir);
      }
    } else if (ext == '.gltf') {
      // binファイルと画像
      final gltfContent = await File(mainFile).readAsString();
      final gltfJson = jsonDecode(gltfContent) as Map<String, dynamic>;
      
      // buffersのURIをコピー
      if (gltfJson.containsKey('buffers')) {
        for (final buffer in gltfJson['buffers'] as List) {
          if (buffer['uri'] != null && !buffer['uri'].startsWith('data:')) {
            final bufferPath = path.join(dir, buffer['uri']);
            if (await File(bufferPath).exists()) {
              await File(bufferPath).copy(path.join(targetDir, buffer['uri']));
            }
          }
        }
      }
      
      // imagesのURIをコピー
      if (gltfJson.containsKey('images')) {
        for (final image in gltfJson['images'] as List) {
          if (image['uri'] != null && !image['uri'].startsWith('data:')) {
            final imagePath = path.join(dir, image['uri']);
            if (await File(imagePath).exists()) {
              await File(imagePath).copy(path.join(targetDir, image['uri']));
            }
          }
        }
      }
    }
  }

  Future<void> _copyMtlTextures(String mtlPath, String sourceDir, String targetDir) async {
    final mtlContent = await File(mtlPath).readAsString();
    final lines = mtlContent.split('\n');
    
    for (final line in lines) {
      final trimmed = line.trim();
      // map_Kd, map_Ka, map_Ks 等のテクスチャ参照
      if (trimmed.startsWith('map_')) {
        final parts = trimmed.split(RegExp(r'\s+'));
        if (parts.length >= 2) {
          final textureName = parts.last;
          final texturePath = path.join(sourceDir, textureName);
          if (await File(texturePath).exists()) {
            await File(texturePath).copy(path.join(targetDir, textureName));
          }
        }
      }
    }
  }

  void _notifyJobUpdate(ImportJob job) {
    _jobs[job.id] = job;
    _jobStreamController.add(job);
  }

  void dispose() {
    _jobStreamController.close();
  }
}
```

### 5. インポートダイアログUI

```dart
// lib/presentation/widgets/import_dialog.dart

import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';

/// インポートダイアログ
class ImportDialog extends StatefulWidget {
  final String projectPath;
  final Function(ImportJob) onImportStarted;

  const ImportDialog({
    super.key,
    required this.projectPath,
    required this.onImportStarted,
  });

  @override
  State<ImportDialog> createState() => _ImportDialogState();
}

class _ImportDialogState extends State<ImportDialog> {
  String? _selectedFilePath;
  ImportFormat? _detectedFormat;
  GeoReference? _geoReference;
  bool _isAnalyzing = false;
  
  // オプション
  bool _copyToProject = true;
  bool _autoConvert = true;
  int? _sourceEpsg;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('3Dデータをインポート'),
      content: SizedBox(
        width: 500,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // ファイル選択
            _buildFileSelector(),
            const SizedBox(height: 16),
            
            // 解析結果
            if (_selectedFilePath != null) ...[
              _buildAnalysisResult(),
              const SizedBox(height: 16),
            ],
            
            // オプション
            _buildOptions(),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('キャンセル'),
        ),
        ElevatedButton(
          onPressed: _selectedFilePath != null && !_isAnalyzing
              ? _startImport
              : null,
          child: const Text('インポート'),
        ),
      ],
    );
  }

  Widget _buildFileSelector() {
    return Row(
      children: [
        Expanded(
          child: Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              _selectedFilePath ?? 'ファイルを選択...',
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
        const SizedBox(width: 8),
        ElevatedButton(
          onPressed: _selectFile,
          child: const Text('参照'),
        ),
      ],
    );
  }

  Widget _buildAnalysisResult() {
    if (_isAnalyzing) {
      return const Row(
        children: [
          SizedBox(
            width: 16,
            height: 16,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          SizedBox(width: 8),
          Text('ファイルを解析中...'),
        ],
      );
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildInfoRow('フォーマット', _detectedFormat?.displayName ?? '不明'),
            _buildInfoRow('カテゴリ', _detectedFormat?.category.displayName ?? '-'),
            if (_geoReference != null) ...[
              const Divider(),
              const Text('ジオリファレンス情報', 
                  style: TextStyle(fontWeight: FontWeight.bold)),
              if (_geoReference!.epsg != null)
                _buildInfoRow('座標系', 'EPSG:${_geoReference!.epsg}'),
              if (_geoReference!.origin != null)
                _buildInfoRow('原点', 
                    '${_geoReference!.origin!.longitude.toStringAsFixed(6)}, '
                    '${_geoReference!.origin!.latitude.toStringAsFixed(6)}'),
              if (_geoReference!.boundingBox != null)
                _buildInfoRow('範囲', 
                    '${_geoReference!.boundingBox!.width.toStringAsFixed(1)} x '
                    '${_geoReference!.boundingBox!.height.toStringAsFixed(1)} m'),
            ] else ...[
              const Divider(),
              const Row(
                children: [
                  Icon(Icons.warning, color: Colors.orange, size: 16),
                  SizedBox(width: 4),
                  Text('ジオリファレンス情報が見つかりません',
                      style: TextStyle(color: Colors.orange)),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          SizedBox(
            width: 100,
            child: Text(label, style: const TextStyle(color: Colors.grey)),
          ),
          Expanded(child: Text(value)),
        ],
      ),
    );
  }

  Widget _buildOptions() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('オプション', style: TextStyle(fontWeight: FontWeight.bold)),
        CheckboxListTile(
          title: const Text('プロジェクトにコピー'),
          subtitle: const Text('元ファイルをプロジェクトフォルダにコピーします'),
          value: _copyToProject,
          onChanged: (v) => setState(() => _copyToProject = v!),
          dense: true,
        ),
        CheckboxListTile(
          title: const Text('3D Tilesへ自動変換'),
          subtitle: const Text('表示最適化のため3D Tiles形式に変換します'),
          value: _autoConvert,
          onChanged: (v) => setState(() => _autoConvert = v!),
          dense: true,
        ),
        if (_geoReference?.epsg == null) ...[
          const SizedBox(height: 8),
          Row(
            children: [
              const Text('座標系（EPSG）: '),
              SizedBox(
                width: 100,
                child: TextField(
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                    hintText: '例: 4326',
                    isDense: true,
                  ),
                  onChanged: (v) => _sourceEpsg = int.tryParse(v),
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  Future<void> _selectFile() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ImportFormat.allExtensions
          .map((e) => e.replaceFirst('.', ''))
          .toList(),
    );

    if (result != null && result.files.single.path != null) {
      setState(() {
        _selectedFilePath = result.files.single.path;
        _isAnalyzing = true;
      });

      await _analyzeFile();
    }
  }

  Future<void> _analyzeFile() async {
    if (_selectedFilePath == null) return;

    try {
      final ext = path.extension(_selectedFilePath!);
      _detectedFormat = ImportFormat.fromExtension(ext);
      
      final analyzer = FileAnalyzerService();
      _geoReference = await analyzer.analyzeFile(_selectedFilePath!);
    } catch (e) {
      _detectedFormat = null;
    } finally {
      setState(() => _isAnalyzing = false);
    }
  }

  void _startImport() {
    if (_selectedFilePath == null) return;

    final options = ImportOptions(
      copyToProject: _copyToProject,
      autoConvert: _autoConvert,
      sourceEpsg: _sourceEpsg ?? _geoReference?.epsg,
    );

    final job = ImportJob.create(
      sourcePath: _selectedFilePath!,
      options: options,
    );

    widget.onImportStarted(job);
    Navigator.pop(context);
  }
}
```

## 技術的な考慮事項

1. **大容量ファイル対応**
   - ファイル解析はストリーム処理で行い、全体を読み込まない
   - 進捗表示で長時間処理のフィードバック

2. **DJI Terra出力の特性**
   - ローカル座標系で出力されることが多い
   - 手動でのジオリファレンス設定が必要な場合がある

3. **座標系の取り扱い**
   - LASファイルはVLRにWKT/GeoTIFFでCRS情報を持つ
   - 座標系が不明な場合はユーザーに入力を促す

4. **関連ファイルの追跡**
   - OBJ→MTL→テクスチャの参照を追跡
   - glTF→bin/画像の参照を追跡

## 成果物・完了条件

- [ ] LAS/LAZファイルのヘッダ解析が動作する
- [ ] OBJ/glTF/GLBファイルのインポートが動作する
- [ ] ジオリファレンス情報の自動検出が動作する
- [ ] ファイルのプロジェクトへのコピーが動作する
- [ ] 関連ファイル（MTL, テクスチャ等）も一緒にコピーされる
- [ ] インポートダイアログが正常に動作する

## 次工程への引き継ぎ事項

- インポートされたファイルの3D Tiles変換は工程06で実装
- レイヤーへの追加・表示設定は工程07で実装
