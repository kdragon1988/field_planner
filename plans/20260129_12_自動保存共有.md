# 工程12: 自動保存・共有・最終調整

## 目的・概要

アプリケーションの信頼性を高める自動保存・リカバリ機能、プロジェクト共有のためのエクスポート/インポート機能を実装する。最終的なテスト・受け入れ基準検証も行う。

## 対応する機能要件

- FR-03: プロジェクト共有用エクスポート（ZIP）
- FR-04: 共有プロジェクトのインポート（ZIP→展開→整合性チェック）
- NFR-10: 自動保存（例：2分毎、世代管理）
- NFR-11: クラッシュ時復元（リカバリ）
- NFR-12: プロジェクト整合性チェック（参照ファイル欠落検知）

## 実装タスク詳細

### 1. 自動保存サービス

```dart
// lib/data/services/auto_save_service.dart

import 'dart:async';
import 'dart:io';

/// 自動保存サービス
/// 
/// 定期的な自動保存とバックアップ管理を行う
class AutoSaveService {
  static const int defaultIntervalSeconds = 120; // 2分
  static const int maxBackupGenerations = 5;
  static const String backupDirName = 'backups';
  
  Timer? _autoSaveTimer;
  final ProjectRepository _projectRepository;
  final PlacementRepository _placementRepository;
  final MeasurementRepository _measurementRepository;
  
  String? _currentProjectPath;
  bool _isDirty = false;
  int _intervalSeconds = defaultIntervalSeconds;
  
  final _autoSaveStreamController = StreamController<AutoSaveEvent>.broadcast();
  Stream<AutoSaveEvent> get autoSaveStream => _autoSaveStreamController.stream;

  AutoSaveService(
    this._projectRepository,
    this._placementRepository,
    this._measurementRepository,
  );

  /// 自動保存を開始
  void start(String projectPath, {int? intervalSeconds}) {
    _currentProjectPath = projectPath;
    _intervalSeconds = intervalSeconds ?? defaultIntervalSeconds;
    
    _autoSaveTimer?.cancel();
    _autoSaveTimer = Timer.periodic(
      Duration(seconds: _intervalSeconds),
      (_) => _performAutoSave(),
    );
    
    debugPrint('AutoSave started: interval=${_intervalSeconds}s');
  }

  /// 自動保存を停止
  void stop() {
    _autoSaveTimer?.cancel();
    _autoSaveTimer = null;
    _currentProjectPath = null;
    debugPrint('AutoSave stopped');
  }

  /// 変更フラグを設定
  void markDirty() {
    _isDirty = true;
  }

  /// 即座に保存を実行
  Future<void> saveNow() async {
    await _performAutoSave(force: true);
  }

  /// 自動保存を実行
  Future<void> _performAutoSave({bool force = false}) async {
    if (_currentProjectPath == null) return;
    if (!_isDirty && !force) return;
    
    try {
      _autoSaveStreamController.add(AutoSaveEvent.started);
      
      // バックアップを作成
      await _createBackup();
      
      // 現在の状態を保存
      // (実際の保存はProjectProvider等から呼び出される想定)
      
      _isDirty = false;
      _autoSaveStreamController.add(AutoSaveEvent.completed);
      
      debugPrint('AutoSave completed');
    } catch (e) {
      _autoSaveStreamController.add(AutoSaveEvent.failed);
      debugPrint('AutoSave failed: $e');
    }
  }

  /// バックアップを作成
  Future<void> _createBackup() async {
    if (_currentProjectPath == null) return;
    
    final backupDir = Directory(
      path.join(_currentProjectPath!, backupDirName),
    );
    
    if (!await backupDir.exists()) {
      await backupDir.create();
    }
    
    // タイムスタンプ付きバックアップファイル名
    final timestamp = DateTime.now().toIso8601String()
        .replaceAll(':', '-')
        .replaceAll('.', '-');
    final backupName = 'backup_$timestamp';
    final backupPath = path.join(backupDir.path, backupName);
    
    // 現在のproject.jsonをコピー
    final projectFile = File(path.join(_currentProjectPath!, 'project.json'));
    if (await projectFile.exists()) {
      await projectFile.copy('$backupPath.json');
    }
    
    // 配置物データもコピー
    final placementsFile = File(path.join(_currentProjectPath!, 'placements.json'));
    if (await placementsFile.exists()) {
      await placementsFile.copy('${backupPath}_placements.json');
    }
    
    // 計測データもコピー
    final measurementsFile = File(path.join(_currentProjectPath!, 'measurements.json'));
    if (await measurementsFile.exists()) {
      await measurementsFile.copy('${backupPath}_measurements.json');
    }
    
    // 古いバックアップを削除
    await _cleanupOldBackups(backupDir);
  }

  /// 古いバックアップを削除
  Future<void> _cleanupOldBackups(Directory backupDir) async {
    final files = await backupDir.list().toList();
    final backupFiles = files
        .whereType<File>()
        .where((f) => path.basename(f.path).startsWith('backup_'))
        .toList();
    
    // ファイル名でソート（新しい順）
    backupFiles.sort((a, b) => b.path.compareTo(a.path));
    
    // 最大世代数を超えたら削除
    if (backupFiles.length > maxBackupGenerations * 3) { // 3ファイル/世代
      final toDelete = backupFiles.skip(maxBackupGenerations * 3);
      for (final file in toDelete) {
        await file.delete();
      }
    }
  }

  void dispose() {
    stop();
    _autoSaveStreamController.close();
  }
}

/// 自動保存イベント
enum AutoSaveEvent {
  started,
  completed,
  failed,
}
```

### 2. リカバリサービス

```dart
// lib/data/services/recovery_service.dart

/// リカバリサービス
/// 
/// クラッシュ時の復元機能を提供
class RecoveryService {
  static const String recoveryFileName = '.recovery';
  
  final ProjectRepository _projectRepository;

  RecoveryService(this._projectRepository);

  /// リカバリファイルを作成
  Future<void> createRecoveryPoint(String projectPath) async {
    final recoveryFile = File(path.join(projectPath, recoveryFileName));
    
    final recoveryData = {
      'timestamp': DateTime.now().toIso8601String(),
      'projectPath': projectPath,
      'version': '1.0.0',
    };
    
    await recoveryFile.writeAsString(jsonEncode(recoveryData));
  }

  /// リカバリファイルを削除（正常終了時）
  Future<void> clearRecoveryPoint(String projectPath) async {
    final recoveryFile = File(path.join(projectPath, recoveryFileName));
    if (await recoveryFile.exists()) {
      await recoveryFile.delete();
    }
  }

  /// リカバリが必要かチェック
  Future<RecoveryInfo?> checkRecovery(String projectPath) async {
    final recoveryFile = File(path.join(projectPath, recoveryFileName));
    
    if (!await recoveryFile.exists()) {
      return null;
    }
    
    try {
      final content = await recoveryFile.readAsString();
      final data = jsonDecode(content) as Map<String, dynamic>;
      
      // バックアップファイルを探す
      final backupDir = Directory(path.join(projectPath, 'backups'));
      List<BackupInfo> backups = [];
      
      if (await backupDir.exists()) {
        final files = await backupDir.list().toList();
        final backupFiles = files
            .whereType<File>()
            .where((f) => path.basename(f.path).endsWith('.json') &&
                         path.basename(f.path).startsWith('backup_'))
            .toList();
        
        for (final file in backupFiles) {
          final name = path.basename(file.path);
          final stat = await file.stat();
          backups.add(BackupInfo(
            path: file.path,
            name: name,
            timestamp: stat.modified,
          ));
        }
        
        backups.sort((a, b) => b.timestamp.compareTo(a.timestamp));
      }
      
      return RecoveryInfo(
        crashTimestamp: DateTime.parse(data['timestamp'] as String),
        availableBackups: backups,
      );
    } catch (e) {
      debugPrint('Failed to read recovery file: $e');
      return null;
    }
  }

  /// バックアップからリカバリ
  Future<bool> recoverFromBackup(
    String projectPath,
    String backupPath,
  ) async {
    try {
      // バックアップファイルを元の場所にコピー
      final backupFile = File(backupPath);
      final targetFile = File(path.join(projectPath, 'project.json'));
      
      await backupFile.copy(targetFile.path);
      
      // 配置物バックアップがあれば復元
      final placementsBackup = backupPath.replaceAll('.json', '_placements.json');
      if (await File(placementsBackup).exists()) {
        await File(placementsBackup).copy(
          path.join(projectPath, 'placements.json'),
        );
      }
      
      // 計測バックアップがあれば復元
      final measurementsBackup = backupPath.replaceAll('.json', '_measurements.json');
      if (await File(measurementsBackup).exists()) {
        await File(measurementsBackup).copy(
          path.join(projectPath, 'measurements.json'),
        );
      }
      
      // リカバリファイルを削除
      await clearRecoveryPoint(projectPath);
      
      return true;
    } catch (e) {
      debugPrint('Recovery failed: $e');
      return false;
    }
  }
}

/// リカバリ情報
class RecoveryInfo {
  final DateTime crashTimestamp;
  final List<BackupInfo> availableBackups;

  RecoveryInfo({
    required this.crashTimestamp,
    required this.availableBackups,
  });
}

/// バックアップ情報
class BackupInfo {
  final String path;
  final String name;
  final DateTime timestamp;

  BackupInfo({
    required this.path,
    required this.name,
    required this.timestamp,
  });
}
```

### 3. プロジェクト共有サービス

```dart
// lib/data/services/project_sharing_service.dart

import 'package:archive/archive.dart';

/// プロジェクト共有サービス
/// 
/// ZIPエクスポート/インポート機能を提供
class ProjectSharingService {
  final ProjectRepository _projectRepository;

  ProjectSharingService(this._projectRepository);

  /// プロジェクトをZIPにエクスポート
  /// 
  /// [projectPath] プロジェクトフォルダパス
  /// [outputPath] ZIP出力先パス
  /// [includeOriginalData] 元データ(imports/)を含めるか
  Future<String> exportToZip({
    required String projectPath,
    required String outputPath,
    bool includeOriginalData = true,
  }) async {
    final archive = Archive();
    final projectDir = Directory(projectPath);
    final projectName = path.basename(projectPath);
    
    // プロジェクトフォルダ内のファイルを追加
    await for (final entity in projectDir.list(recursive: true)) {
      if (entity is File) {
        final relativePath = path.relative(entity.path, from: projectPath);
        
        // バックアップフォルダはスキップ
        if (relativePath.startsWith('backups')) continue;
        
        // リカバリファイルはスキップ
        if (relativePath == '.recovery') continue;
        
        // imports/フォルダのスキップオプション
        if (!includeOriginalData && relativePath.startsWith('imports')) {
          continue;
        }
        
        final bytes = await entity.readAsBytes();
        archive.addFile(ArchiveFile(
          '$projectName/$relativePath',
          bytes.length,
          bytes,
        ));
      }
    }
    
    // ZIPエンコード
    final zipData = ZipEncoder().encode(archive);
    if (zipData == null) {
      throw ExportException('ZIPエンコードに失敗しました');
    }
    
    // ファイルに書き込み
    final zipFile = File(outputPath);
    await zipFile.writeAsBytes(zipData);
    
    return outputPath;
  }

  /// ZIPからプロジェクトをインポート
  /// 
  /// [zipPath] ZIPファイルパス
  /// [targetDir] 展開先ディレクトリ
  Future<ImportResult> importFromZip({
    required String zipPath,
    required String targetDir,
  }) async {
    final zipFile = File(zipPath);
    if (!await zipFile.exists()) {
      throw ImportException('ZIPファイルが見つかりません: $zipPath');
    }
    
    final bytes = await zipFile.readAsBytes();
    final archive = ZipDecoder().decodeBytes(bytes);
    
    // プロジェクト名を取得
    String? projectName;
    for (final file in archive) {
      final parts = file.name.split('/');
      if (parts.isNotEmpty && parts.first.isNotEmpty) {
        projectName = parts.first;
        break;
      }
    }
    
    if (projectName == null) {
      throw ImportException('無効なプロジェクトアーカイブです');
    }
    
    // 展開先パス
    final projectPath = path.join(targetDir, projectName);
    
    // 既存チェック
    if (await Directory(projectPath).exists()) {
      throw ImportException('同名のプロジェクトが既に存在します: $projectName');
    }
    
    // 展開
    for (final file in archive) {
      final filePath = path.join(targetDir, file.name);
      
      if (file.isFile) {
        final outFile = File(filePath);
        await outFile.create(recursive: true);
        await outFile.writeAsBytes(file.content as List<int>);
      } else {
        await Directory(filePath).create(recursive: true);
      }
    }
    
    // 整合性チェック
    final validation = await _projectRepository.validateProject(projectPath);
    
    return ImportResult(
      projectPath: projectPath,
      projectName: projectName,
      validation: validation,
    );
  }

  /// プロジェクトの整合性をチェック
  Future<ProjectValidationResult> validateProject(String projectPath) async {
    return await _projectRepository.validateProject(projectPath);
  }
}

/// エクスポート例外
class ExportException implements Exception {
  final String message;
  ExportException(this.message);
  
  @override
  String toString() => 'ExportException: $message';
}

/// インポート例外
class ImportException implements Exception {
  final String message;
  ImportException(this.message);
  
  @override
  String toString() => 'ImportException: $message';
}

/// インポート結果
class ImportResult {
  final String projectPath;
  final String projectName;
  final ProjectValidationResult validation;

  ImportResult({
    required this.projectPath,
    required this.projectName,
    required this.validation,
  });
}
```

### 4. リカバリダイアログUI

```dart
// lib/presentation/widgets/recovery_dialog.dart

/// リカバリダイアログ
class RecoveryDialog extends StatelessWidget {
  final RecoveryInfo recoveryInfo;
  final Function(String? backupPath) onRecover;

  const RecoveryDialog({
    super.key,
    required this.recoveryInfo,
    required this.onRecover,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Row(
        children: const [
          Icon(Icons.warning, color: Colors.orange),
          SizedBox(width: 8),
          Text('リカバリが必要です'),
        ],
      ),
      content: SizedBox(
        width: 450,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '前回の終了が正常に行われませんでした。\n'
              '最終クラッシュ: ${_formatDateTime(recoveryInfo.crashTimestamp)}',
            ),
            const SizedBox(height: 16),
            
            if (recoveryInfo.availableBackups.isNotEmpty) ...[
              const Text('利用可能なバックアップ:', 
                  style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              
              Container(
                height: 150,
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: ListView.builder(
                  itemCount: recoveryInfo.availableBackups.length,
                  itemBuilder: (context, index) {
                    final backup = recoveryInfo.availableBackups[index];
                    return ListTile(
                      leading: const Icon(Icons.restore),
                      title: Text(_formatDateTime(backup.timestamp)),
                      subtitle: Text(backup.name),
                      onTap: () {
                        Navigator.pop(context);
                        onRecover(backup.path);
                      },
                    );
                  },
                ),
              ),
            ] else ...[
              const Text('利用可能なバックアップがありません。'),
            ],
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () {
            Navigator.pop(context);
            onRecover(null); // バックアップなしで続行
          },
          child: const Text('バックアップなしで続行'),
        ),
        if (recoveryInfo.availableBackups.isNotEmpty)
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              onRecover(recoveryInfo.availableBackups.first.path);
            },
            child: const Text('最新のバックアップから復元'),
          ),
      ],
    );
  }

  String _formatDateTime(DateTime dt) {
    return '${dt.year}/${dt.month}/${dt.day} ${dt.hour}:${dt.minute.toString().padLeft(2, '0')}';
  }
}
```

### 5. エクスポートダイアログUI

```dart
// lib/presentation/widgets/export_dialog.dart

/// エクスポートダイアログ
class ExportDialog extends ConsumerStatefulWidget {
  final String projectPath;

  const ExportDialog({super.key, required this.projectPath});

  @override
  ConsumerState<ExportDialog> createState() => _ExportDialogState();
}

class _ExportDialogState extends ConsumerState<ExportDialog> {
  bool _includeOriginalData = true;
  bool _isExporting = false;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('プロジェクトをエクスポート'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'プロジェクトをZIPファイルとしてエクスポートします。\n'
            '他のPCで開くことができます。',
          ),
          const SizedBox(height: 16),
          
          CheckboxListTile(
            title: const Text('元データを含める'),
            subtitle: const Text('インポートした元ファイル(LAS/OBJ等)を含めます'),
            value: _includeOriginalData,
            onChanged: (v) => setState(() => _includeOriginalData = v!),
          ),
          
          if (!_includeOriginalData)
            Container(
              padding: const EdgeInsets.all(8),
              color: Colors.orange.withOpacity(0.1),
              child: const Row(
                children: [
                  Icon(Icons.warning, color: Colors.orange, size: 16),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      '元データを含めない場合、インポート先で3Dデータが表示されない可能性があります',
                      style: TextStyle(fontSize: 12),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: _isExporting ? null : () => Navigator.pop(context),
          child: const Text('キャンセル'),
        ),
        ElevatedButton(
          onPressed: _isExporting ? null : _export,
          child: _isExporting
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('エクスポート'),
        ),
      ],
    );
  }

  Future<void> _export() async {
    setState(() => _isExporting = true);
    
    try {
      // 保存先を選択
      final outputPath = await FilePicker.platform.saveFile(
        dialogTitle: 'エクスポート先を選択',
        fileName: '${path.basename(widget.projectPath)}.zip',
        type: FileType.custom,
        allowedExtensions: ['zip'],
      );
      
      if (outputPath == null) {
        setState(() => _isExporting = false);
        return;
      }
      
      // エクスポート実行
      final service = ref.read(projectSharingServiceProvider);
      await service.exportToZip(
        projectPath: widget.projectPath,
        outputPath: outputPath,
        includeOriginalData: _includeOriginalData,
      );
      
      Navigator.pop(context);
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('エクスポートしました: $outputPath')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('エクスポートに失敗しました: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      setState(() => _isExporting = false);
    }
  }
}
```

### 6. 受け入れテスト項目

```markdown
## 受け入れテストチェックリスト

### AC-01: プロジェクト共有
- [ ] プロジェクトをZIPでエクスポートできる
- [ ] エクスポートしたZIPを別PCで開ける
- [ ] 同一表示・同一配置・同一計測が復元できる

### AC-02: 3Dデータ表示
- [ ] LAS/LAZファイルを取り込める
- [ ] タイル化後にスムーズに移動/ズームできる
- [ ] 点群が正しい位置に表示される

### AC-03: アセット配置
- [ ] アセットパレットからアイテムを選択できる
- [ ] 地面スナップで配置できる
- [ ] 回転/スケール/複製が直感的に行える
- [ ] グリッドスナップが動作する

### AC-04: 計測機能
- [ ] 距離/面積計測を保存できる
- [ ] 再起動後も計測結果が表示される
- [ ] CSV出力できる

### AC-05: 自動保存・リカバリ
- [ ] 2分毎に自動保存される
- [ ] クラッシュ後にリカバリダイアログが表示される
- [ ] バックアップから復元できる

### AC-06: パフォーマンス
- [ ] 10M点規模の点群が快適に表示される（タイル化後）
- [ ] 操作遅延が体感100ms以内
- [ ] 数百の配置物でも保存/読込が正常

### AC-07: その他
- [ ] Windows 10/11で動作する
- [ ] macOS 12+で動作する
- [ ] キーボードショートカットが動作する
```

## 技術的な考慮事項

1. **自動保存の信頼性**
   - 保存中にクラッシュしてもデータが壊れないよう、一時ファイル経由で保存
   - 保存完了後にリカバリファイルを更新

2. **ZIP圧縮**
   - 大きな点群データは圧縮効率が低いため、元データの同梱はオプション
   - UTF-8ファイル名に対応

3. **クロスプラットフォーム**
   - パス区切り文字の違いを考慮
   - ファイル権限の違いを考慮

## 成果物・完了条件

- [ ] 自動保存が2分毎に動作する
- [ ] バックアップが世代管理される（最大5世代）
- [ ] クラッシュ後にリカバリダイアログが表示される
- [ ] ZIPエクスポートが動作する
- [ ] ZIPインポートが動作し、整合性チェックされる
- [ ] 全受け入れテスト項目をクリア

## プロジェクト完了基準

1. 全12工程の実装が完了
2. 受け入れテスト項目を全てクリア
3. Windows/macOSで動作確認完了
4. パフォーマンス目標を達成
5. 主要なバグが修正済み
