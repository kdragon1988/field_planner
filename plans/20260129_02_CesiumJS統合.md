# 工程02: CesiumJS統合・JS Bridge実装

## 目的・概要

Flutter DesktopアプリケーションにCesiumJSを組み込み、3D地図表示機能を実現する。FlutterとJavaScript間の双方向通信（JS Bridge）を構築し、カメラ操作やイベントハンドリングの基盤を整備する。

## 対応する機能要件

- FR-20: ベースマップ選択（Cesium imagery）
- FR-22: 2D/3D表示切替
- FR-50: ビュー操作（回転/パン/ズーム、ホーム復帰）
- FR-51: 検索（座標/地名）

## 実装タスク詳細

### 1. CesiumJS アセットの準備

#### CesiumJSファイルの配置

```
assets/
└── cesium/
    ├── index.html           # CesiumJSをホストするHTML
    ├── cesium_bridge.js     # Flutter連携用JavaScriptモジュール
    ├── Cesium/              # CesiumJSライブラリ（CDN or ローカル）
    │   ├── Cesium.js
    │   ├── Widgets/
    │   └── Assets/
    └── styles/
        └── cesium_custom.css
```

#### index.html の構成

```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Field Planner - Cesium View</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <link href="styles/cesium_custom.css" rel="stylesheet">
</head>
<body>
  <div id="cesiumContainer"></div>
  <script src="cesium_bridge.js"></script>
</body>
</html>
```

### 2. JS Bridge アーキテクチャ設計

```
┌─────────────────────────────────────────────────────────────┐
│                     Flutter Desktop                          │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              CesiumController                        │    │
│  │  - flyTo()                                          │    │
│  │  - setBaseMap()                                     │    │
│  │  - addTileset()                                     │    │
│  │  - onCameraChange callback                          │    │
│  └─────────────────────────────────────────────────────┘    │
│                           │                                  │
│                     Platform Channel                         │
│                           │                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              WebViewBridge                          │    │
│  │  - executeJavaScript()                              │    │
│  │  - addJavaScriptChannel()                           │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                           │
                     postMessage / eval
                           │
┌─────────────────────────────────────────────────────────────┐
│                     CesiumJS (WebView)                       │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              cesium_bridge.js                       │    │
│  │  - handleFlutterMessage()                           │    │
│  │  - sendToFlutter()                                  │    │
│  │  - CesiumViewer instance                            │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 3. cesium_bridge.js 実装

```javascript
/**
 * CesiumJS - Flutter Bridge
 * FlutterアプリケーションとCesiumJS間の通信を担当
 */

// グローバル変数
let viewer = null;
let currentCamera = null;

/**
 * Cesium Viewerを初期化
 * @param {Object} config - 初期設定
 */
function initializeCesium(config) {
  Cesium.Ion.defaultAccessToken = config.ionToken || '';
  
  viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProvider: Cesium.createWorldTerrain(),
    baseLayerPicker: false,
    geocoder: false,
    homeButton: false,
    sceneModePicker: false,
    navigationHelpButton: false,
    animation: false,
    timeline: false,
    fullscreenButton: false,
    vrButton: false,
    infoBox: true,
    selectionIndicator: true,
  });

  // カメラ変更イベントのリスナー
  viewer.camera.changed.addEventListener(() => {
    const position = viewer.camera.positionCartographic;
    sendToFlutter('cameraChanged', {
      longitude: Cesium.Math.toDegrees(position.longitude),
      latitude: Cesium.Math.toDegrees(position.latitude),
      height: position.height,
      heading: Cesium.Math.toDegrees(viewer.camera.heading),
      pitch: Cesium.Math.toDegrees(viewer.camera.pitch),
      roll: Cesium.Math.toDegrees(viewer.camera.roll)
    });
  });

  // クリックイベントのリスナー
  viewer.screenSpaceEventHandler.setInputAction((click) => {
    const cartesian = viewer.camera.pickEllipsoid(click.position);
    if (cartesian) {
      const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
      sendToFlutter('mapClicked', {
        longitude: Cesium.Math.toDegrees(cartographic.longitude),
        latitude: Cesium.Math.toDegrees(cartographic.latitude),
        height: cartographic.height
      });
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  sendToFlutter('initialized', { success: true });
}

/**
 * カメラを指定位置に移動
 * @param {Object} params - 移動先パラメータ
 */
function flyTo(params) {
  viewer.camera.flyTo({
    destination: Cesium.Cartesian3.fromDegrees(
      params.longitude,
      params.latitude,
      params.height || 1000
    ),
    orientation: {
      heading: Cesium.Math.toRadians(params.heading || 0),
      pitch: Cesium.Math.toRadians(params.pitch || -45),
      roll: 0
    },
    duration: params.duration || 2
  });
}

/**
 * 3D Tilesを追加
 * @param {Object} params - Tileset設定
 */
function addTileset(params) {
  const tileset = viewer.scene.primitives.add(
    new Cesium.Cesium3DTileset({
      url: params.url,
      maximumScreenSpaceError: params.maxError || 16
    })
  );
  
  tileset.readyPromise.then(() => {
    sendToFlutter('tilesetLoaded', {
      id: params.id,
      boundingSphere: tileset.boundingSphere
    });
  }).catch((error) => {
    sendToFlutter('tilesetError', {
      id: params.id,
      error: error.message
    });
  });
  
  return tileset;
}

/**
 * ベースマップを変更
 * @param {string} provider - プロバイダ名
 */
function setBaseMap(provider) {
  viewer.imageryLayers.removeAll();
  
  let imageryProvider;
  switch (provider) {
    case 'bing':
      imageryProvider = new Cesium.BingMapsImageryProvider({
        url: 'https://dev.virtualearth.net',
        key: '', // APIキーは設定から取得
        mapStyle: Cesium.BingMapsStyle.AERIAL_WITH_LABELS
      });
      break;
    case 'osm':
      imageryProvider = new Cesium.OpenStreetMapImageryProvider({
        url: 'https://a.tile.openstreetmap.org/'
      });
      break;
    case 'esri':
      imageryProvider = new Cesium.ArcGisMapServerImageryProvider({
        url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
      });
      break;
    default:
      imageryProvider = new Cesium.OpenStreetMapImageryProvider({
        url: 'https://a.tile.openstreetmap.org/'
      });
  }
  
  viewer.imageryLayers.addImageryProvider(imageryProvider);
}

/**
 * Flutterからのメッセージを処理
 * @param {string} method - メソッド名
 * @param {Object} params - パラメータ
 */
function handleFlutterMessage(method, params) {
  switch (method) {
    case 'initialize':
      initializeCesium(params);
      break;
    case 'flyTo':
      flyTo(params);
      break;
    case 'addTileset':
      addTileset(params);
      break;
    case 'setBaseMap':
      setBaseMap(params.provider);
      break;
    case 'setSceneMode':
      viewer.scene.mode = params.mode === '2d' 
        ? Cesium.SceneMode.SCENE2D 
        : Cesium.SceneMode.SCENE3D;
      break;
    default:
      console.warn('Unknown method:', method);
  }
}

/**
 * Flutterへメッセージを送信
 * @param {string} event - イベント名
 * @param {Object} data - データ
 */
function sendToFlutter(event, data) {
  if (window.FlutterChannel) {
    window.FlutterChannel.postMessage(JSON.stringify({
      event: event,
      data: data
    }));
  }
}

// グローバルに公開
window.CesiumBridge = {
  handleFlutterMessage,
  sendToFlutter
};
```

### 4. Flutter側 CesiumController 実装

```dart
// lib/infrastructure/webview/cesium_controller.dart

import 'dart:convert';
import 'package:flutter/foundation.dart';

/// CesiumJSとの通信を管理するコントローラ
/// 
/// WebView経由でCesiumJSの各種操作を行い、
/// イベントコールバックを受け取る
class CesiumController extends ChangeNotifier {
  final WebViewController _webViewController;
  
  /// カメラ位置変更時のコールバック
  Function(CameraPosition)? onCameraChanged;
  
  /// マップクリック時のコールバック
  Function(GeoPosition)? onMapClicked;
  
  /// 3D Tiles読み込み完了時のコールバック
  Function(String tilesetId)? onTilesetLoaded;

  CesiumController(this._webViewController) {
    _setupJavaScriptChannels();
  }

  void _setupJavaScriptChannels() {
    _webViewController.addJavaScriptChannel(
      'FlutterChannel',
      onMessageReceived: _handleMessage,
    );
  }

  void _handleMessage(JavaScriptMessage message) {
    try {
      final data = jsonDecode(message.message);
      final event = data['event'] as String;
      final payload = data['data'] as Map<String, dynamic>;

      switch (event) {
        case 'initialized':
          debugPrint('CesiumJS initialized');
          notifyListeners();
          break;
        case 'cameraChanged':
          onCameraChanged?.call(CameraPosition.fromJson(payload));
          break;
        case 'mapClicked':
          onMapClicked?.call(GeoPosition.fromJson(payload));
          break;
        case 'tilesetLoaded':
          onTilesetLoaded?.call(payload['id'] as String);
          break;
        case 'tilesetError':
          debugPrint('Tileset error: ${payload['error']}');
          break;
      }
    } catch (e) {
      debugPrint('Error handling Cesium message: $e');
    }
  }

  /// CesiumJSを初期化
  Future<void> initialize({String? ionToken}) async {
    await _executeMethod('initialize', {
      'ionToken': ionToken ?? '',
    });
  }

  /// 指定座標にカメラを移動
  Future<void> flyTo({
    required double longitude,
    required double latitude,
    double height = 1000,
    double heading = 0,
    double pitch = -45,
    double duration = 2,
  }) async {
    await _executeMethod('flyTo', {
      'longitude': longitude,
      'latitude': latitude,
      'height': height,
      'heading': heading,
      'pitch': pitch,
      'duration': duration,
    });
  }

  /// 3D Tilesを追加
  Future<void> addTileset({
    required String id,
    required String url,
    double maxError = 16,
  }) async {
    await _executeMethod('addTileset', {
      'id': id,
      'url': url,
      'maxError': maxError,
    });
  }

  /// ベースマップを変更
  Future<void> setBaseMap(String provider) async {
    await _executeMethod('setBaseMap', {
      'provider': provider,
    });
  }

  /// 2D/3D表示モードを切り替え
  Future<void> setSceneMode(SceneMode mode) async {
    await _executeMethod('setSceneMode', {
      'mode': mode == SceneMode.scene2D ? '2d' : '3d',
    });
  }

  Future<void> _executeMethod(String method, Map<String, dynamic> params) async {
    final script = '''
      window.CesiumBridge.handleFlutterMessage('$method', ${jsonEncode(params)});
    ''';
    await _webViewController.runJavaScript(script);
  }
}

/// カメラ位置
class CameraPosition {
  final double longitude;
  final double latitude;
  final double height;
  final double heading;
  final double pitch;
  final double roll;

  CameraPosition({
    required this.longitude,
    required this.latitude,
    required this.height,
    required this.heading,
    required this.pitch,
    required this.roll,
  });

  factory CameraPosition.fromJson(Map<String, dynamic> json) {
    return CameraPosition(
      longitude: (json['longitude'] as num).toDouble(),
      latitude: (json['latitude'] as num).toDouble(),
      height: (json['height'] as num).toDouble(),
      heading: (json['heading'] as num).toDouble(),
      pitch: (json['pitch'] as num).toDouble(),
      roll: (json['roll'] as num).toDouble(),
    );
  }
}

/// 地理座標
class GeoPosition {
  final double longitude;
  final double latitude;
  final double height;

  GeoPosition({
    required this.longitude,
    required this.latitude,
    required this.height,
  });

  factory GeoPosition.fromJson(Map<String, dynamic> json) {
    return GeoPosition(
      longitude: (json['longitude'] as num).toDouble(),
      latitude: (json['latitude'] as num).toDouble(),
      height: (json['height'] as num).toDouble(),
    );
  }
}

/// シーンモード
enum SceneMode {
  scene2D,
  scene3D,
}
```

### 5. WebView Widget 実装

```dart
// lib/presentation/widgets/cesium_map_widget.dart

import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';

/// CesiumJSを表示するWebViewウィジェット
class CesiumMapWidget extends StatefulWidget {
  final Function(CesiumController)? onControllerCreated;
  final String? initialPosition; // "lat,lon,height"

  const CesiumMapWidget({
    super.key,
    this.onControllerCreated,
    this.initialPosition,
  });

  @override
  State<CesiumMapWidget> createState() => _CesiumMapWidgetState();
}

class _CesiumMapWidgetState extends State<CesiumMapWidget> {
  late WebViewController _webViewController;
  CesiumController? _cesiumController;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _initWebView();
  }

  void _initWebView() {
    _webViewController = WebViewController()
      ..setJavaScriptMode(JavaScriptMode.unrestricted)
      ..setBackgroundColor(Colors.black)
      ..setNavigationDelegate(
        NavigationDelegate(
          onPageFinished: (url) {
            _onPageLoaded();
          },
          onWebResourceError: (error) {
            debugPrint('WebView error: ${error.description}');
          },
        ),
      )
      ..loadFlutterAsset('assets/cesium/index.html');
  }

  void _onPageLoaded() {
    _cesiumController = CesiumController(_webViewController);
    _cesiumController!.initialize().then((_) {
      setState(() => _isLoading = false);
      widget.onControllerCreated?.call(_cesiumController!);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        WebViewWidget(controller: _webViewController),
        if (_isLoading)
          const Center(
            child: CircularProgressIndicator(),
          ),
      ],
    );
  }

  @override
  void dispose() {
    _cesiumController?.dispose();
    super.dispose();
  }
}
```

## 技術的な考慮事項

1. **パフォーマンス最適化**
   - JavaScript実行は非同期で行い、UIをブロックしない
   - 頻繁なカメラ変更イベントはデバウンス処理
   - WebViewのハードウェアアクセラレーションを有効化

2. **エラーハンドリング**
   - WebViewの読み込みエラーを適切に処理
   - JavaScript実行エラーのキャッチとログ出力
   - ネットワーク切断時のフォールバック表示

3. **セキュリティ**
   - APIキーはDart側で管理し、JSに渡す際は最小限に
   - 外部スクリプトの実行を制限

4. **クロスプラットフォーム**
   - Windows: WebView2使用時の初期化待機
   - macOS: WKWebViewのサンドボックス設定

## 成果物・完了条件

- [ ] CesiumJSがWebView内で正常に表示される
- [ ] Flutter → JavaScript のメソッド呼び出しが動作する
- [ ] JavaScript → Flutter のイベント通知が動作する
- [ ] カメラ移動（flyTo）が正常に動作する
- [ ] マップクリックイベントが取得できる
- [ ] ベースマップの切り替えが動作する

## 次工程への引き継ぎ事項

- `CesiumController` を使用してプロジェクト管理画面から初期座標を設定
- 3D Tiles追加機能は工程05-06で拡張
- ベースマップ選択UIは工程04で実装
