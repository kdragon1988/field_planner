# 工程11: UI/UX・画面レイアウト

## 目的・概要

アプリケーション全体のUI/UXを実装する。メイン画面レイアウト（左パネル、中央3Dビュー、右インスペクタ）、ツールバー、ステータスバー、キーボードショートカット、スクリーンショット機能を構築する。

## 対応する機能要件

- FR-50: ビュー操作（回転/パン/ズーム、ホーム復帰）
- FR-51: 検索（座標/地名）
- FR-52: スクリーンショット出力（PNG）
- FR-53: 簡易ビューモード（プレゼン用：UI最小化）
- 画面仕様（8.1 メイン画面構成、8.2 アセット配置UX、8.3 計測UX）

## 実装タスク詳細

### 1. メイン画面レイアウト

```dart
// lib/presentation/screens/main_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// メイン画面
class MainScreen extends ConsumerStatefulWidget {
  const MainScreen({super.key});

  @override
  ConsumerState<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends ConsumerState<MainScreen> {
  // パネル表示状態
  bool _showLeftPanel = true;
  bool _showRightPanel = true;
  bool _presentationMode = false;
  
  // パネルサイズ
  double _leftPanelWidth = 280;
  double _rightPanelWidth = 320;
  
  // 現在のツール
  ToolMode _currentTool = ToolMode.select;

  @override
  Widget build(BuildContext context) {
    final projectState = ref.watch(currentProjectProvider);
    
    if (projectState.project == null) {
      return const StartScreen();
    }
    
    return Scaffold(
      body: KeyboardListener(
        focusNode: FocusNode(),
        onKeyEvent: _handleKeyEvent,
        child: Column(
          children: [
            // メニューバー
            if (!_presentationMode) _buildMenuBar(),
            
            // ツールバー
            if (!_presentationMode) _buildToolbar(),
            
            // メインコンテンツ
            Expanded(
              child: Row(
                children: [
                  // 左パネル
                  if (_showLeftPanel && !_presentationMode)
                    _buildLeftPanel(),
                  
                  // 3Dビュー（中央）
                  Expanded(
                    child: _build3DView(),
                  ),
                  
                  // 右パネル
                  if (_showRightPanel && !_presentationMode)
                    _buildRightPanel(),
                ],
              ),
            ),
            
            // ステータスバー
            if (!_presentationMode) _buildStatusBar(),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuBar() {
    return Container(
      height: 32,
      color: Theme.of(context).colorScheme.surface,
      child: Row(
        children: [
          _buildMenuButton('ファイル', [
            MenuItemData('新規プロジェクト', () => _createNewProject(), 'Ctrl+N'),
            MenuItemData('開く...', () => _openProject(), 'Ctrl+O'),
            MenuItemData.separator(),
            MenuItemData('保存', () => _saveProject(), 'Ctrl+S'),
            MenuItemData('別名で保存...', () => _saveProjectAs(), 'Ctrl+Shift+S'),
            MenuItemData.separator(),
            MenuItemData('インポート...', () => _showImportDialog(), 'Ctrl+I'),
            MenuItemData('エクスポート', () => _showExportMenu(), null),
            MenuItemData.separator(),
            MenuItemData('終了', () => _exitApp(), null),
          ]),
          _buildMenuButton('編集', [
            MenuItemData('元に戻す', () => _undo(), 'Ctrl+Z'),
            MenuItemData('やり直し', () => _redo(), 'Ctrl+Y'),
            MenuItemData.separator(),
            MenuItemData('コピー', () => _copy(), 'Ctrl+C'),
            MenuItemData('貼り付け', () => _paste(), 'Ctrl+V'),
            MenuItemData('削除', () => _delete(), 'Delete'),
            MenuItemData.separator(),
            MenuItemData('すべて選択', () => _selectAll(), 'Ctrl+A'),
          ]),
          _buildMenuButton('表示', [
            MenuItemData('左パネル', () {
              setState(() => _showLeftPanel = !_showLeftPanel);
            }, 'F3', isChecked: _showLeftPanel),
            MenuItemData('右パネル', () {
              setState(() => _showRightPanel = !_showRightPanel);
            }, 'F4', isChecked: _showRightPanel),
            MenuItemData.separator(),
            MenuItemData('2D表示', () => _setSceneMode2D(), null),
            MenuItemData('3D表示', () => _setSceneMode3D(), null),
            MenuItemData.separator(),
            MenuItemData('プレゼンテーションモード', () {
              setState(() => _presentationMode = !_presentationMode);
            }, 'F11', isChecked: _presentationMode),
          ]),
          _buildMenuButton('ツール', [
            MenuItemData('距離計測', () => _startDistanceMeasurement(), 'D'),
            MenuItemData('面積計測', () => _startAreaMeasurement(), 'A'),
            MenuItemData('高さ計測', () => _startHeightMeasurement(), 'H'),
            MenuItemData.separator(),
            MenuItemData('スクリーンショット', () => _takeScreenshot(), 'Ctrl+P'),
          ]),
          _buildMenuButton('ヘルプ', [
            MenuItemData('ショートカット一覧', () => _showShortcutHelp(), 'F1'),
            MenuItemData('バージョン情報', () => _showAbout(), null),
          ]),
          const Spacer(),
          // プロジェクト名
          Text(
            ref.watch(currentProjectProvider).project?.name ?? '',
            style: const TextStyle(fontWeight: FontWeight.w500),
          ),
          const SizedBox(width: 16),
        ],
      ),
    );
  }

  Widget _buildMenuButton(String label, List<MenuItemData> items) {
    return PopupMenuButton<VoidCallback>(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12),
        child: Center(child: Text(label)),
      ),
      itemBuilder: (context) => items.map((item) {
        if (item.isSeparator) {
          return const PopupMenuDivider() as PopupMenuEntry<VoidCallback>;
        }
        return PopupMenuItem<VoidCallback>(
          value: item.action,
          child: Row(
            children: [
              if (item.isChecked != null)
                SizedBox(
                  width: 24,
                  child: item.isChecked!
                      ? const Icon(Icons.check, size: 16)
                      : null,
                ),
              Expanded(child: Text(item.label)),
              if (item.shortcut != null)
                Text(
                  item.shortcut!,
                  style: TextStyle(color: Colors.grey[600], fontSize: 12),
                ),
            ],
          ),
        );
      }).toList(),
      onSelected: (action) => action(),
    );
  }

  Widget _buildToolbar() {
    return Container(
      height: 48,
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor),
        ),
      ),
      child: Row(
        children: [
          // 選択ツール
          _buildToolButton(
            icon: Icons.near_me,
            label: '選択',
            isActive: _currentTool == ToolMode.select,
            onPressed: () => setState(() => _currentTool = ToolMode.select),
          ),
          const VerticalDivider(),
          
          // 配置ツール
          _buildToolButton(
            icon: Icons.add_location,
            label: '配置',
            isActive: _currentTool == ToolMode.place,
            onPressed: () => setState(() => _currentTool = ToolMode.place),
          ),
          
          // 移動ツール
          _buildToolButton(
            icon: Icons.open_with,
            label: '移動',
            isActive: _currentTool == ToolMode.move,
            onPressed: () => setState(() => _currentTool = ToolMode.move),
          ),
          
          // 回転ツール
          _buildToolButton(
            icon: Icons.rotate_right,
            label: '回転',
            isActive: _currentTool == ToolMode.rotate,
            onPressed: () => setState(() => _currentTool = ToolMode.rotate),
          ),
          
          // スケールツール
          _buildToolButton(
            icon: Icons.open_in_full,
            label: 'スケール',
            isActive: _currentTool == ToolMode.scale,
            onPressed: () => setState(() => _currentTool = ToolMode.scale),
          ),
          
          const VerticalDivider(),
          
          // 計測ツール
          _buildToolButton(
            icon: Icons.straighten,
            label: '距離',
            isActive: _currentTool == ToolMode.measureDistance,
            onPressed: () {
              setState(() => _currentTool = ToolMode.measureDistance);
              _startDistanceMeasurement();
            },
          ),
          _buildToolButton(
            icon: Icons.square_foot,
            label: '面積',
            isActive: _currentTool == ToolMode.measureArea,
            onPressed: () {
              setState(() => _currentTool = ToolMode.measureArea);
              _startAreaMeasurement();
            },
          ),
          _buildToolButton(
            icon: Icons.height,
            label: '高さ',
            isActive: _currentTool == ToolMode.measureHeight,
            onPressed: () {
              setState(() => _currentTool = ToolMode.measureHeight);
              _startHeightMeasurement();
            },
          ),
          
          const Spacer(),
          
          // スナップ設定
          _buildSnapToggle(),
          
          const VerticalDivider(),
          
          // ビュー操作
          _buildToolButton(
            icon: Icons.home,
            label: 'ホーム',
            onPressed: _goHome,
          ),
          _buildToolButton(
            icon: Icons.search,
            label: '検索',
            onPressed: _showSearchDialog,
          ),
          _buildToolButton(
            icon: Icons.camera_alt,
            label: 'スクショ',
            onPressed: _takeScreenshot,
          ),
        ],
      ),
    );
  }

  Widget _buildToolButton({
    required IconData icon,
    required String label,
    bool isActive = false,
    VoidCallback? onPressed,
  }) {
    return Tooltip(
      message: label,
      child: IconButton(
        icon: Icon(icon, size: 20),
        style: IconButton.styleFrom(
          backgroundColor: isActive
              ? Theme.of(context).primaryColor.withOpacity(0.2)
              : null,
          foregroundColor: isActive
              ? Theme.of(context).primaryColor
              : null,
        ),
        onPressed: onPressed,
      ),
    );
  }

  Widget _buildSnapToggle() {
    return Row(
      children: [
        const Text('スナップ:', style: TextStyle(fontSize: 12)),
        const SizedBox(width: 4),
        _buildMiniToggle('G', 'グリッド', true),
        _buildMiniToggle('地', '地面', true),
        _buildMiniToggle('角', '角度', true),
      ],
    );
  }

  Widget _buildMiniToggle(String label, String tooltip, bool isOn) {
    return Tooltip(
      message: tooltip,
      child: Container(
        width: 24,
        height: 24,
        margin: const EdgeInsets.symmetric(horizontal: 2),
        decoration: BoxDecoration(
          color: isOn ? Theme.of(context).primaryColor : Colors.grey[300],
          borderRadius: BorderRadius.circular(4),
        ),
        child: Center(
          child: Text(
            label,
            style: TextStyle(
              fontSize: 10,
              color: isOn ? Colors.white : Colors.black54,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLeftPanel() {
    return Container(
      width: _leftPanelWidth,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          right: BorderSide(color: Theme.of(context).dividerColor),
        ),
      ),
      child: DefaultTabController(
        length: 3,
        child: Column(
          children: [
            const TabBar(
              tabs: [
                Tab(text: 'レイヤー'),
                Tab(text: 'アセット'),
                Tab(text: '計測'),
              ],
            ),
            Expanded(
              child: TabBarView(
                children: [
                  const LayerPanel(),
                  AssetPalette(
                    onAssetSelected: (asset) {
                      ref.read(placementControllerProvider)
                          .startPlacementMode(asset.id);
                      setState(() => _currentTool = ToolMode.place);
                    },
                  ),
                  const MeasurementPanel(),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _build3DView() {
    return Stack(
      children: [
        // CesiumJS WebView
        CesiumMapWidget(
          onControllerCreated: (controller) {
            ref.read(cesiumControllerProvider.notifier).setController(controller);
          },
        ),
        
        // オーバーレイUI（ズームボタン等）
        Positioned(
          right: 16,
          bottom: 16,
          child: _buildViewControls(),
        ),
        
        // 座標表示
        Positioned(
          left: 16,
          bottom: 16,
          child: _buildCoordinateDisplay(),
        ),
      ],
    );
  }

  Widget _buildViewControls() {
    return Column(
      children: [
        FloatingActionButton.small(
          heroTag: 'zoom_in',
          onPressed: _zoomIn,
          child: const Icon(Icons.add),
        ),
        const SizedBox(height: 8),
        FloatingActionButton.small(
          heroTag: 'zoom_out',
          onPressed: _zoomOut,
          child: const Icon(Icons.remove),
        ),
        const SizedBox(height: 8),
        FloatingActionButton.small(
          heroTag: 'compass',
          onPressed: _resetNorth,
          child: const Icon(Icons.explore),
        ),
      ],
    );
  }

  Widget _buildCoordinateDisplay() {
    final camera = ref.watch(cameraPositionProvider);
    
    if (camera == null) return const SizedBox.shrink();
    
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.black54,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        '${camera.latitude.toStringAsFixed(6)}°, ${camera.longitude.toStringAsFixed(6)}° | H: ${camera.height.toStringAsFixed(1)}m',
        style: const TextStyle(color: Colors.white, fontSize: 12),
      ),
    );
  }

  Widget _buildRightPanel() {
    return Container(
      width: _rightPanelWidth,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          left: BorderSide(color: Theme.of(context).dividerColor),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Padding(
            padding: EdgeInsets.all(12),
            child: Text('プロパティ', style: TextStyle(fontWeight: FontWeight.bold)),
          ),
          const Divider(height: 1),
          Expanded(
            child: const PlacementInspector(),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusBar() {
    final isDirty = ref.watch(currentProjectProvider).isDirty;
    
    return Container(
      height: 24,
      padding: const EdgeInsets.symmetric(horizontal: 8),
      color: Theme.of(context).colorScheme.surface,
      child: Row(
        children: [
          // 保存状態
          Icon(
            isDirty ? Icons.edit : Icons.check,
            size: 14,
            color: isDirty ? Colors.orange : Colors.green,
          ),
          const SizedBox(width: 4),
          Text(
            isDirty ? '未保存の変更があります' : '保存済み',
            style: const TextStyle(fontSize: 12),
          ),
          const Spacer(),
          // ツールヒント
          Text(
            _getToolHint(),
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
        ],
      ),
    );
  }

  String _getToolHint() {
    switch (_currentTool) {
      case ToolMode.select:
        return 'クリックで選択、Shift+クリックで複数選択';
      case ToolMode.place:
        return 'クリックで配置、右クリックでキャンセル';
      case ToolMode.move:
        return 'ドラッグで移動';
      case ToolMode.rotate:
        return 'ドラッグで回転、Shiftで15°スナップ';
      case ToolMode.scale:
        return 'ドラッグでスケール、Shiftで均一スケール';
      case ToolMode.measureDistance:
      case ToolMode.measureArea:
        return 'クリックでポイント追加、ダブルクリックで確定';
      case ToolMode.measureHeight:
        return '2点をクリックして高さを計測';
    }
  }

  void _handleKeyEvent(KeyEvent event) {
    if (event is! KeyDownEvent) return;
    
    final isCtrl = HardwareKeyboard.instance.isControlPressed;
    final isShift = HardwareKeyboard.instance.isShiftPressed;
    
    // ショートカットキー処理
    switch (event.logicalKey) {
      case LogicalKeyboardKey.keyS:
        if (isCtrl) {
          if (isShift) {
            _saveProjectAs();
          } else {
            _saveProject();
          }
        }
        break;
      case LogicalKeyboardKey.keyO:
        if (isCtrl) _openProject();
        break;
      case LogicalKeyboardKey.keyN:
        if (isCtrl) _createNewProject();
        break;
      case LogicalKeyboardKey.keyZ:
        if (isCtrl) _undo();
        break;
      case LogicalKeyboardKey.keyY:
        if (isCtrl) _redo();
        break;
      case LogicalKeyboardKey.keyD:
        if (isCtrl) {
          _duplicateSelected();
        } else {
          _startDistanceMeasurement();
        }
        break;
      case LogicalKeyboardKey.keyA:
        if (isCtrl) {
          _selectAll();
        } else {
          _startAreaMeasurement();
        }
        break;
      case LogicalKeyboardKey.keyH:
        _startHeightMeasurement();
        break;
      case LogicalKeyboardKey.delete:
        _delete();
        break;
      case LogicalKeyboardKey.escape:
        _cancelCurrentAction();
        break;
      case LogicalKeyboardKey.f3:
        setState(() => _showLeftPanel = !_showLeftPanel);
        break;
      case LogicalKeyboardKey.f4:
        setState(() => _showRightPanel = !_showRightPanel);
        break;
      case LogicalKeyboardKey.f11:
        setState(() => _presentationMode = !_presentationMode);
        break;
    }
  }

  // アクションメソッド（省略）
  void _createNewProject() {}
  void _openProject() {}
  void _saveProject() {}
  void _saveProjectAs() {}
  void _showImportDialog() {}
  void _showExportMenu() {}
  void _exitApp() {}
  void _undo() {}
  void _redo() {}
  void _copy() {}
  void _paste() {}
  void _delete() {}
  void _selectAll() {}
  void _duplicateSelected() {}
  void _setSceneMode2D() {}
  void _setSceneMode3D() {}
  void _startDistanceMeasurement() {}
  void _startAreaMeasurement() {}
  void _startHeightMeasurement() {}
  void _takeScreenshot() {}
  void _showShortcutHelp() {}
  void _showAbout() {}
  void _goHome() {}
  void _showSearchDialog() {}
  void _zoomIn() {}
  void _zoomOut() {}
  void _resetNorth() {}
  void _cancelCurrentAction() {}
}

/// ツールモード
enum ToolMode {
  select,
  place,
  move,
  rotate,
  scale,
  measureDistance,
  measureArea,
  measureHeight,
}

/// メニューアイテムデータ
class MenuItemData {
  final String label;
  final VoidCallback? action;
  final String? shortcut;
  final bool? isChecked;
  final bool isSeparator;

  MenuItemData(this.label, this.action, this.shortcut, {this.isChecked})
      : isSeparator = false;
  
  MenuItemData.separator()
      : label = '',
        action = null,
        shortcut = null,
        isChecked = null,
        isSeparator = true;
}
```

### 2. 検索ダイアログ

```dart
// lib/presentation/widgets/search_dialog.dart

/// 座標/地名検索ダイアログ
class SearchDialog extends StatefulWidget {
  final Function(double lat, double lon) onLocationSelected;

  const SearchDialog({
    super.key,
    required this.onLocationSelected,
  });

  @override
  State<SearchDialog> createState() => _SearchDialogState();
}

class _SearchDialogState extends State<SearchDialog> {
  final _controller = TextEditingController();
  List<SearchResult>? _results;
  bool _isSearching = false;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('場所を検索'),
      content: SizedBox(
        width: 400,
        height: 300,
        child: Column(
          children: [
            TextField(
              controller: _controller,
              decoration: InputDecoration(
                hintText: '地名または座標（35.6895, 139.6917）',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _isSearching
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : null,
              ),
              onSubmitted: _search,
            ),
            const SizedBox(height: 16),
            Expanded(
              child: _results == null
                  ? const Center(child: Text('検索してください'))
                  : _results!.isEmpty
                      ? const Center(child: Text('結果が見つかりません'))
                      : ListView.builder(
                          itemCount: _results!.length,
                          itemBuilder: (context, index) {
                            final result = _results![index];
                            return ListTile(
                              leading: const Icon(Icons.place),
                              title: Text(result.name),
                              subtitle: Text(
                                '${result.latitude.toStringAsFixed(4)}, ${result.longitude.toStringAsFixed(4)}',
                              ),
                              onTap: () {
                                widget.onLocationSelected(
                                  result.latitude,
                                  result.longitude,
                                );
                                Navigator.pop(context);
                              },
                            );
                          },
                        ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('閉じる'),
        ),
      ],
    );
  }

  void _search(String query) async {
    if (query.isEmpty) return;
    
    setState(() => _isSearching = true);
    
    // 座標パターンをチェック
    final coordPattern = RegExp(r'^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$');
    final match = coordPattern.firstMatch(query);
    
    if (match != null) {
      // 座標入力
      final lat = double.parse(match.group(1)!);
      final lon = double.parse(match.group(2)!);
      setState(() {
        _results = [
          SearchResult(
            name: '座標: $lat, $lon',
            latitude: lat,
            longitude: lon,
          ),
        ];
        _isSearching = false;
      });
    } else {
      // 地名検索（Nominatim API使用）
      try {
        final results = await _searchByName(query);
        setState(() {
          _results = results;
          _isSearching = false;
        });
      } catch (e) {
        setState(() {
          _results = [];
          _isSearching = false;
        });
      }
    }
  }

  Future<List<SearchResult>> _searchByName(String query) async {
    // Nominatim APIを使用した地名検索
    // 実際の実装ではHTTPリクエストを行う
    // ここでは簡略化
    return [];
  }
}

class SearchResult {
  final String name;
  final double latitude;
  final double longitude;

  SearchResult({
    required this.name,
    required this.latitude,
    required this.longitude,
  });
}
```

### 3. スクリーンショット機能

```dart
// lib/data/services/screenshot_service.dart

import 'dart:typed_data';
import 'dart:ui' as ui;

/// スクリーンショットサービス
class ScreenshotService {
  final CesiumController _cesiumController;

  ScreenshotService(this._cesiumController);

  /// スクリーンショットを撮影してファイルに保存
  Future<String?> captureAndSave({
    String? outputPath,
    bool includeUI = false,
  }) async {
    try {
      // CesiumJSからスクリーンショットを取得
      final base64Image = await _cesiumController.captureScreenshot();
      
      if (base64Image == null) return null;
      
      // Base64をデコード
      final bytes = base64Decode(base64Image);
      
      // 保存先を決定
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'screenshot_$timestamp.png';
      final savePath = outputPath ?? 
          path.join(await _getScreenshotDirectory(), fileName);
      
      // ファイルに保存
      await File(savePath).writeAsBytes(bytes);
      
      return savePath;
    } catch (e) {
      debugPrint('Screenshot failed: $e');
      return null;
    }
  }

  /// スクリーンショット保存ディレクトリを取得
  Future<String> _getScreenshotDirectory() async {
    final appDir = await getApplicationDocumentsDirectory();
    final screenshotDir = Directory(path.join(appDir.path, 'screenshots'));
    
    if (!await screenshotDir.exists()) {
      await screenshotDir.create(recursive: true);
    }
    
    return screenshotDir.path;
  }
}
```

### 4. ショートカットヘルプダイアログ

```dart
// lib/presentation/widgets/shortcut_help_dialog.dart

/// ショートカットヘルプダイアログ
class ShortcutHelpDialog extends StatelessWidget {
  const ShortcutHelpDialog({super.key});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('キーボードショートカット'),
      content: SizedBox(
        width: 500,
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildCategory('ファイル', [
                _ShortcutItem('Ctrl+N', '新規プロジェクト'),
                _ShortcutItem('Ctrl+O', '開く'),
                _ShortcutItem('Ctrl+S', '保存'),
                _ShortcutItem('Ctrl+Shift+S', '別名で保存'),
                _ShortcutItem('Ctrl+I', 'インポート'),
              ]),
              _buildCategory('編集', [
                _ShortcutItem('Ctrl+Z', '元に戻す'),
                _ShortcutItem('Ctrl+Y', 'やり直し'),
                _ShortcutItem('Ctrl+C', 'コピー'),
                _ShortcutItem('Ctrl+V', '貼り付け'),
                _ShortcutItem('Ctrl+D', '複製'),
                _ShortcutItem('Delete', '削除'),
                _ShortcutItem('Ctrl+A', 'すべて選択'),
                _ShortcutItem('Escape', 'キャンセル'),
              ]),
              _buildCategory('計測', [
                _ShortcutItem('D', '距離計測'),
                _ShortcutItem('A', '面積計測'),
                _ShortcutItem('H', '高さ計測'),
              ]),
              _buildCategory('表示', [
                _ShortcutItem('F3', '左パネル表示/非表示'),
                _ShortcutItem('F4', '右パネル表示/非表示'),
                _ShortcutItem('F11', 'プレゼンテーションモード'),
                _ShortcutItem('Ctrl+P', 'スクリーンショット'),
              ]),
              _buildCategory('配置操作', [
                _ShortcutItem('Shift', 'スナップ強制'),
                _ShortcutItem('Alt', 'スナップ解除'),
                _ShortcutItem('右クリック', '配置キャンセル'),
              ]),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('閉じる'),
        ),
      ],
    );
  }

  Widget _buildCategory(String title, List<_ShortcutItem> items) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 8),
          child: Text(
            title,
            style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
          ),
        ),
        ...items.map((item) => Padding(
          padding: const EdgeInsets.symmetric(vertical: 4),
          child: Row(
            children: [
              SizedBox(
                width: 120,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.grey[200],
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    item.shortcut,
                    style: const TextStyle(fontFamily: 'monospace'),
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Text(item.description),
            ],
          ),
        )),
        const Divider(),
      ],
    );
  }
}

class _ShortcutItem {
  final String shortcut;
  final String description;

  _ShortcutItem(this.shortcut, this.description);
}
```

## 技術的な考慮事項

1. **レスポンシブ対応**
   - ウィンドウサイズに応じてパネル幅を調整
   - 小さいウィンドウではパネルを自動的に折りたたむ

2. **パフォーマンス**
   - 不要な再描画を避けるためのConstウィジェット活用
   - 重い処理は非同期で実行

3. **アクセシビリティ**
   - キーボードショートカットの完全対応
   - ツールチップの充実

4. **テーマ対応**
   - ダークモード/ライトモードの切り替え対応

## 成果物・完了条件

- [ ] メイン画面レイアウトが正しく表示される
- [ ] 左パネル（レイヤー/アセット/計測）が動作する
- [ ] 右パネル（プロパティインスペクタ）が動作する
- [ ] ツールバーの各ボタンが機能する
- [ ] ステータスバーに状態が表示される
- [ ] キーボードショートカットが動作する
- [ ] 検索ダイアログが動作する
- [ ] スクリーンショット機能が動作する
- [ ] プレゼンテーションモードが動作する

## 次工程への引き継ぎ事項

- UIテーマ/カスタマイズ設定は設定画面で管理
- パネル状態の保存は工程12の自動保存機能と連携
